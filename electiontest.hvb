Issue: Safety violation

================================================
Running thread T0: __init__()
mode:  runnable atomic
stack: ['[]']
state id: 1
================================================

Step 1:
  program counter:   0
  hvm code:          Frame __init__()
  explanation:       method "__init__" with argument () set to []
  file:              electiontest.hny
  start statement:   line=1 column=1
  end statement:     line=44 column=23
  source code:       from synch import Lock, acquire, release
  shared variables:  { }
  method variables:  { result: None }
  call trace:        __init__()
  stack:             [{:}]

Step 2:
  program counter:   1
  hvm code:          Jump 52
  explanation:       jump over method definition: set program counter to 52
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/list.hny
  start statement:   line=2 column=1
  end statement:     line=2 column=20
  source code:       def subseq(s, b, e):
                     ^^^

Step 3:
  program counter:   52
  hvm code:          Push PC(55)
  explanation:       push constant PC(55)
  start statement:   line=11 column=1
  end statement:     line=11 column=24
  source code:       builtin tail "list$tail"
                             ^^^^
  stack:             [{:}, PC(55)]

Step 4:
  program counter:   53
  hvm code:          Builtin(list$tail)
  explanation:       pop pc (PC(55)) and bind to built-in method list$tail
  source code:       builtin tail "list$tail"
                     ^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 5:
  program counter:   54
  hvm code:          Jump 371
  explanation:       jump over method definition: set program counter to 371
  start statement:   line=12 column=1
  end statement:     line=12 column=12
  source code:       def tail(s):
                     ^^^

Step 6:
  program counter:   371
  hvm code:          Push PC(374)
  explanation:       push constant PC(374)
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/bag.hny
  start statement:   line=15 column=1
  end statement:     line=15 column=39
  source code:       builtin multiplicity "bag$multiplicity"
                             ^^^^^^^^^^^^
  stack:             [{:}, PC(374)]

Step 7:
  program counter:   372
  hvm code:          Builtin(bag$multiplicity)
  explanation:       pop pc (PC(374)) and bind to built-in method bag$multiplicity
  source code:       builtin multiplicity "bag$multiplicity"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 8:
  program counter:   373
  hvm code:          Jump 392
  explanation:       jump over method definition: set program counter to 392
  start statement:   line=16 column=1
  end statement:     line=16 column=26
  source code:       def multiplicity(bg, elt):
                     ^^^

Step 9:
  program counter:   392
  hvm code:          Push PC(395)
  explanation:       push constant PC(395)
  start statement:   line=22 column=1
  end statement:     line=22 column=23
  source code:       builtin size "bag$size"
                             ^^^^
  stack:             [{:}, PC(395)]

Step 10:
  program counter:   393
  hvm code:          Builtin(bag$size)
  explanation:       pop pc (PC(395)) and bind to built-in method bag$size
  source code:       builtin size "bag$size"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 11:
  program counter:   394
  hvm code:          Jump 414
  explanation:       jump over method definition: set program counter to 414
  start statement:   line=23 column=1
  end statement:     line=23 column=13
  source code:       def size(bg):
                     ^^^

Step 12:
  program counter:   414
  hvm code:          Push PC(417)
  explanation:       push constant PC(417)
  start statement:   line=28 column=1
  end statement:     line=28 column=23
  source code:       builtin bmin "bag$bmin"
                             ^^^^
  stack:             [{:}, PC(417)]

Step 13:
  program counter:   415
  hvm code:          Builtin(bag$bmin)
  explanation:       pop pc (PC(417)) and bind to built-in method bag$bmin
  source code:       builtin bmin "bag$bmin"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 14:
  program counter:   416
  hvm code:          Jump 433
  explanation:       jump over method definition: set program counter to 433
  start statement:   line=29 column=1
  end statement:     line=29 column=13
  source code:       def bmin(bg):
                     ^^^

Step 15:
  program counter:   433
  hvm code:          Push PC(436)
  explanation:       push constant PC(436)
  start statement:   line=33 column=1
  end statement:     line=33 column=23
  source code:       builtin bmax "bag$bmax"
                             ^^^^
  stack:             [{:}, PC(436)]

Step 16:
  program counter:   434
  hvm code:          Builtin(bag$bmax)
  explanation:       pop pc (PC(436)) and bind to built-in method bag$bmax
  source code:       builtin bmax "bag$bmax"
                     ^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 17:
  program counter:   435
  hvm code:          Jump 461
  explanation:       jump over method definition: set program counter to 461
  start statement:   line=34 column=1
  end statement:     line=34 column=13
  source code:       def bmax(bg):
                     ^^^

Step 18:
  program counter:   461
  hvm code:          Push PC(464)
  explanation:       push constant PC(464)
  start statement:   line=41 column=1
  end statement:     line=41 column=21
  source code:       builtin add "bag$add"
                             ^^^
  stack:             [{:}, PC(464)]

Step 19:
  program counter:   462
  hvm code:          Builtin(bag$add)
  explanation:       pop pc (PC(464)) and bind to built-in method bag$add
  source code:       builtin add "bag$add"
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 20:
  program counter:   463
  hvm code:          Jump 490
  explanation:       jump over method definition: set program counter to 490
  start statement:   line=42 column=1
  end statement:     line=42 column=17
  source code:       def add(bg, elt):
                     ^^^

Step 21:
  program counter:   490
  hvm code:          Push PC(493)
  explanation:       push constant PC(493)
  start statement:   line=49 column=1
  end statement:     line=49 column=27
  source code:       builtin remove "bag$remove"
                             ^^^^^^
  stack:             [{:}, PC(493)]

Step 22:
  program counter:   491
  hvm code:          Builtin(bag$remove)
  explanation:       pop pc (PC(493)) and bind to built-in method bag$remove
  source code:       builtin remove "bag$remove"
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 23:
  program counter:   492
  hvm code:          Jump 1296
  explanation:       jump over method definition: set program counter to 1296
  start statement:   line=50 column=1
  end statement:     line=50 column=20
  source code:       def remove(bg, elt):
                     ^^^

Step 24:
  program counter:   1296
  hvm code:          Push 0
  explanation:       push constant 0
  file:              electiontest.hny
  start statement:   line=4 column=1
  end statement:     line=4 column=20
  source code:       threads_executed = 0
                                        ^
  stack:             [{:}, 0]

Step 25:
  program counter:   1297
  hvm code:          Store threads_executed
  explanation:       pop value (0) and store into variable threads_executed
  source code:       threads_executed = 0
                     ^^^^^^^^^^^^^^^^^^
  shared variables:  { threads_executed: 0 }
  stack:             [{:}]

Step 26:
  program counter:   1298
  hvm code:          Push 4
  explanation:       push constant 4
  start statement:   line=5 column=1
  end statement:     line=5 column=29
  source code:       number_of_spawned_threads = 4
                                                 ^
  stack:             [{:}, 4]

Step 27:
  program counter:   1299
  hvm code:          Store number_of_spawned_threads
  explanation:       pop value (4) and store into variable number_of_spawned_threads
  source code:       number_of_spawned_threads = 4
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}]

Step 28:
  program counter:   1300
  hvm code:          Push 2
  explanation:       push constant 2
  start statement:   line=7 column=1
  end statement:     line=7 column=18
  source code:       NUM_CANDIDATES = 2
                                      ^
  stack:             [{:}, 2]

Step 29:
  program counter:   1301
  hvm code:          Store NUM_CANDIDATES
  explanation:       pop value (2) and store into variable NUM_CANDIDATES
  source code:       NUM_CANDIDATES = 2
                     ^^^^^^^^^^^^^^^^
  shared variables:  { NUM_CANDIDATES: 2, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}]

Step 30:
  program counter:   1302
  hvm code:          Push 3
  explanation:       push constant 3
  start statement:   line=8 column=1
  end statement:     line=8 column=16
  source code:       NUM_CITIZENS = 3
                                    ^
  stack:             [{:}, 3]

Step 31:
  program counter:   1303
  hvm code:          Store NUM_CITIZENS
  explanation:       pop value (3) and store into variable NUM_CITIZENS
  source code:       NUM_CITIZENS = 3
                     ^^^^^^^^^^^^^^
  shared variables:  { NUM_CANDIDATES: 2, NUM_CITIZENS: 3, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}]

Step 32:
  program counter:   1304
  hvm code:          Push [3, 0]
  explanation:       push constant [3, 0]
  start statement:   line=9 column=1
  end statement:     line=9 column=23
  source code:       EXPECTED_VOTES = [3, 0]
                                       ^^^^
  stack:             [{:}, [ 3, 0 ]]

Step 33:
  program counter:   1305
  hvm code:          Store EXPECTED_VOTES
  explanation:       pop value ([3, 0]) and store into variable EXPECTED_VOTES
  source code:       EXPECTED_VOTES = [3, 0]
                     ^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}]

Step 34:
  program counter:   1306
  hvm code:          Push 0
  explanation:       push constant 0
  start statement:   line=10 column=1
  end statement:     line=10 column=10
  source code:       WINNER = 0
                              ^
  stack:             [{:}, 0]

Step 35:
  program counter:   1307
  hvm code:          Store WINNER
  explanation:       pop value (0) and store into variable WINNER
  source code:       WINNER = 0
                     ^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}]

Step 36:
  program counter:   1308
  hvm code:          Push PC(944)
  explanation:       push program counter constant 944 ("Election")
  start statement:   line=12 column=1
  end statement:     line=12 column=51
  source code:       e = election.Election(NUM_CANDIDATES, NUM_CITIZENS)
                         ^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(944)]

Step 37:
  program counter:   1309
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       e = election.Election(NUM_CANDIDATES, NUM_CITIZENS)
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(944), []]

Step 38:
  program counter:   1310
  hvm code:          Load NUM_CANDIDATES
  explanation:       push value (2) of variable NUM_CANDIDATES
  source code:       e = election.Election(NUM_CANDIDATES, NUM_CITIZENS)
                                           ^^^^^^^^^^^^^^
  stack:             [{:}, PC(944), [], 2]

Step 39:
  program counter:   1311
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, []); insert first value into the second; push result ([2])
  source code:       e = election.Election(NUM_CANDIDATES, NUM_CITIZENS)
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(944), [ 2 ]]

Step 40:
  program counter:   1312
  hvm code:          Load NUM_CITIZENS
  explanation:       push value (3) of variable NUM_CITIZENS
  source code:       e = election.Election(NUM_CANDIDATES, NUM_CITIZENS)
                                                           ^^^^^^^^^^^^
  stack:             [{:}, PC(944), [ 2 ], 3]

Step 41:
  program counter:   1313
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (3, [2]); insert first value into the second; push result ([2, 3])
  source code:       e = election.Election(NUM_CANDIDATES, NUM_CITIZENS)
                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(944), [ 2, 3 ]]

Step 42:
  program counter:   1314
  hvm code:          Apply
  explanation:       pop an argument ([2, 3]) and a program counter value (944: "Election") and call the method
  source code:       e = election.Election(NUM_CANDIDATES, NUM_CITIZENS)
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        __init__() --> Election(2, 3)
  stack:             [{:}, 21042, [ 2, 3 ]]

Step 43:
  program counter:   944
  hvm code:          Frame Election(n, m)
  explanation:       method "Election" with argument (n, m) set to [2, 3]
  file:              electionimpl.hny
  start statement:   line=4 column=1
  end statement:     line=4 column=19
  source code:       def Election(n, m):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { m: 3, n: 2, result: None }
  stack:             [{:}, 21042, { "result": None }]

Step 44:
  program counter:   945
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=5 column=5
  end statement:     line=12 column=5
  source code:       .locks_can:[Lock(),]*n,
  method variables:  { m: 3, n: 2 }

Step 45:
  program counter:   946
  hvm code:          Push {:}
  explanation:       push constant {:}
  start expression:  line=7 column=9
  end expression:    line=11 column=54
  stack:             [{:}, 21042, { "result": None }, {:}]

Step 46:
  program counter:   947
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can"]

Step 47:
  program counter:   948
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", []]

Step 48:
  program counter:   949
  hvm code:          Push PC(679)
  explanation:       push program counter constant 679 ("Lock")
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], PC(679)]

Step 49:
  program counter:   950
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], PC(679), []]

Step 50:
  program counter:   951
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (679: "Lock") and call the method
  source code:       .locks_can:[Lock(),]*n,
  call trace:        __init__() --> Election(2, 3) --> Lock()
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, []]

Step 51:
  program counter:   679
  hvm code:          Frame Lock()
  explanation:       method "Lock" with argument () set to []
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=24 column=1
  end statement:     line=24 column=11
  source code:       def Lock():
                     ^^^^^^^^^^^
  method variables:  { result: None }
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, { "m": 3, "n": 2 }]

Step 52:
  program counter:   680
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=27
  source code:       result = BinSema(False)
                              ^^^^^^^
  method variables:  { }

Step 53:
  program counter:   681
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  start expression:  line=25 column=14
  end expression:    line=25 column=20
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, { "m": 3, "n": 2 }, PC(672)]

Step 54:
  program counter:   682
  hvm code:          Push False
  explanation:       push constant False
  source code:       result = BinSema(False)
                                      ^^^^^
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, { "m": 3, "n": 2 }, PC(672), False]

Step 55:
  program counter:   683
  hvm code:          Apply
  explanation:       pop an argument (False) and a program counter value (672: "BinSema") and call the method
  source code:       result = BinSema(False)
                              ^^^^^^^^^^^^^^
  call trace:        __init__() --> Election(2, 3) --> Lock() --> BinSema(False)
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, { "m": 3, "n": 2 }, 10946, False]

Step 56:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to False
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: False, result: None }
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, { "m": 3, "n": 2 }, 10946, {:}]

Step 57:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: False }

Step 58:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (False) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, { "m": 3, "n": 2 }, 10946, {:}, False]

Step 59:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 60:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, { "m": 3, "n": 2 }, 10946, {:}]

Step 61:
  program counter:   677
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Election(2, 3) --> Lock()
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, { "m": 3, "n": 2 }, False]

Step 62:
  program counter:   684
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  start statement:   line=25 column=5
  end statement:     line=25 column=27
  source code:       result = BinSema(False)
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], 15234, { "m": 3, "n": 2 }]

Step 63:
  program counter:   685
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=24 column=1
  end statement:     line=24 column=11
  source code:       def Lock():
                     ^^^^^^^^^^^
  method variables:  { m: 3, n: 2 }
  call trace:        __init__() --> Election(2, 3)
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [], False]

Step 64:
  program counter:   952
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, []); insert first value into the second; push result ([False])
  file:              electionimpl.hny
  start statement:   line=5 column=5
  end statement:     line=12 column=5
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [ False ]]

Step 65:
  program counter:   953
  hvm code:          LoadVar n
  explanation:       push value (2) of variable "n"
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [ False ], 2]

Step 66:
  program counter:   954
  hvm code:          2-ary *
  explanation:       pop 2 values (2, [False]); create multiple copies of list; push result ([False, False])
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, {:}, "locks_can", [ False, False ]]

Step 67:
  program counter:   955
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([False, False], "locks_can", {:}); add key/value pair to dictionary; push result ({ "locks_can": [False, False] })
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }]

Step 68:
  program counter:   956
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       .locks_cit:[Lock(),]*m,
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit"]

Step 69:
  program counter:   957
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       .locks_cit:[Lock(),]*m,
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", []]

Step 70:
  program counter:   958
  hvm code:          Push PC(679)
  explanation:       push program counter constant 679 ("Lock")
  source code:       .locks_cit:[Lock(),]*m,
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], PC(679)]

Step 71:
  program counter:   959
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       .locks_cit:[Lock(),]*m,
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], PC(679), []]

Step 72:
  program counter:   960
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (679: "Lock") and call the method
  source code:       .locks_cit:[Lock(),]*m,
  call trace:        __init__() --> Election(2, 3) --> Lock()
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, []]

Step 73:
  program counter:   679
  hvm code:          Frame Lock()
  explanation:       method "Lock" with argument () set to []
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=24 column=1
  end statement:     line=24 column=11
  source code:       def Lock():
                     ^^^^^^^^^^^
  method variables:  { result: None }
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, { "m": 3, "n": 2 }]

Step 74:
  program counter:   680
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=27
  source code:       result = BinSema(False)
                              ^^^^^^^
  method variables:  { }

Step 75:
  program counter:   681
  hvm code:          Push PC(672)
  explanation:       push program counter constant 672 ("BinSema")
  start expression:  line=25 column=14
  end expression:    line=25 column=20
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, { "m": 3, "n": 2 }, PC(672)]

Step 76:
  program counter:   682
  hvm code:          Push False
  explanation:       push constant False
  source code:       result = BinSema(False)
                                      ^^^^^
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, { "m": 3, "n": 2 }, PC(672), False]

Step 77:
  program counter:   683
  hvm code:          Apply
  explanation:       pop an argument (False) and a program counter value (672: "BinSema") and call the method
  source code:       result = BinSema(False)
                              ^^^^^^^^^^^^^^
  call trace:        __init__() --> Election(2, 3) --> Lock() --> BinSema(False)
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, { "m": 3, "n": 2 }, 10946, False]

Step 78:
  program counter:   672
  hvm code:          Frame BinSema(acquired)
  explanation:       method "BinSema" with argument acquired set to False
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { acquired: False, result: None }
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, { "m": 3, "n": 2 }, 10946, {:}]

Step 79:
  program counter:   673
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=22 column=5
  end statement:     line=22 column=21
  source code:       result = acquired
                              ^^^^^^^^
  method variables:  { acquired: False }

Step 80:
  program counter:   674
  hvm code:          LoadVar acquired
  explanation:       push value (False) of variable "acquired"
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, { "m": 3, "n": 2 }, 10946, {:}, False]

Step 81:
  program counter:   675
  hvm code:          DelVar acquired
  explanation:       delete method variable acquired
  start expression:  line=22 column=14
  end expression:    line=22 column=21
  method variables:  { }

Step 82:
  program counter:   676
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = acquired
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, { "m": 3, "n": 2 }, 10946, {:}]

Step 83:
  program counter:   677
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=21 column=1
  end statement:     line=21 column=22
  source code:       def BinSema(acquired):
                     ^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  call trace:        __init__() --> Election(2, 3) --> Lock()
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, { "m": 3, "n": 2 }, False]

Step 84:
  program counter:   684
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  start statement:   line=25 column=5
  end statement:     line=25 column=27
  source code:       result = BinSema(False)
                     ^^^^^^^^
  method variables:  { result: False }
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], 15378, { "m": 3, "n": 2 }]

Step 85:
  program counter:   685
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=24 column=1
  end statement:     line=24 column=11
  source code:       def Lock():
                     ^^^^^^^^^^^
  method variables:  { m: 3, n: 2 }
  call trace:        __init__() --> Election(2, 3)
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [], False]

Step 86:
  program counter:   961
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (False, []); insert first value into the second; push result ([False])
  file:              electionimpl.hny
  start statement:   line=5 column=5
  end statement:     line=12 column=5
  source code:       .locks_cit:[Lock(),]*m,
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [ False ]]

Step 87:
  program counter:   962
  hvm code:          LoadVar m
  explanation:       push value (3) of variable "m"
  source code:       .locks_cit:[Lock(),]*m,
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [ False ], 3]

Step 88:
  program counter:   963
  hvm code:          2-ary *
  explanation:       pop 2 values (3, [False]); create multiple copies of list; push result ([False, False, False])
  source code:       .locks_cit:[Lock(),]*m,
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ] }, "locks_cit", [ False, False, False ]]

Step 89:
  program counter:   964
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([False, False, False], "locks_cit", { "locks_can": [False, False] }); add key/value pair to dictionary; push result ({ "locks_can": [False, False], "locks_cit": [False, False, False] })
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }]

Step 90:
  program counter:   965
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       .candidates:[0,]*n, 
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, "candidates"]

Step 91:
  program counter:   966
  hvm code:          Push [0,]
  explanation:       push constant [0,]
  source code:       .candidates:[0,]*n, 
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, "candidates", [ 0 ]]

Step 92:
  program counter:   967
  hvm code:          LoadVar n
  explanation:       push value (2) of variable "n"
  source code:       .candidates:[0,]*n, 
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, "candidates", [ 0 ], 2]

Step 93:
  program counter:   968
  hvm code:          DelVar n
  explanation:       delete method variable n
  start expression:  line=10 column=26
  end expression:    line=10 column=26
  method variables:  { m: 3 }

Step 94:
  program counter:   969
  hvm code:          2-ary *
  explanation:       pop 2 values (2, [0]); create multiple copies of list; push result ([0, 0])
  source code:       .candidates:[0,]*n, 
  stack:             [{:}, 21042, { "result": None }, { "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, "candidates", [ 0, 0 ]]

Step 95:
  program counter:   970
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([0, 0], "candidates", { "locks_can": [False, False], "locks_cit": [False, False, False] }); add key/value pair to dictionary; push result ({ "candidates": [0, 0], "locks_can": [False, False], "locks_cit": [False, False, False] })
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, { "candidates": [ 0, 0 ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }]

Step 96:
  program counter:   971
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       .citizens:[{.voted: False, .voted_for: -1},]*m
  stack:             [{:}, 21042, { "result": None }, { "candidates": [ 0, 0 ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, "citizens"]

Step 97:
  program counter:   972
  hvm code:          Push [{ "voted":False, "voted_for":-1 },]
  explanation:       push constant [{ "voted":False, "voted_for":-1 },]
  source code:       .citizens:[{.voted: False, .voted_for: -1},]*m
  stack:             [{:}, 21042, { "result": None }, { "candidates": [ 0, 0 ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, "citizens", [ { "voted": False, "voted_for": -1 } ]]

Step 98:
  program counter:   973
  hvm code:          LoadVar m
  explanation:       push value (3) of variable "m"
  source code:       .citizens:[{.voted: False, .voted_for: -1},]*m
  stack:             [{:}, 21042, { "result": None }, { "candidates": [ 0, 0 ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, "citizens", [ { "voted": False, "voted_for": -1 } ], 3]

Step 99:
  program counter:   974
  hvm code:          DelVar m
  explanation:       delete method variable m
  start expression:  line=11 column=54
  end expression:    line=11 column=54
  method variables:  { }

Step 100:
  program counter:   975
  hvm code:          2-ary *
  explanation:       pop 2 values (3, [{ "voted": False, "voted_for": -1 }]); create multiple copies of list; push result ([{ "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }])
  source code:       .citizens:[{.voted: False, .voted_for: -1},]*m
  stack:             [{:}, 21042, { "result": None }, { "candidates": [ 0, 0 ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, "citizens", [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ]]

Step 101:
  program counter:   976
  hvm code:          3-ary DictAdd
  explanation:       pop 3 values ([{ "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }], "citizens", { "candidates": [0, 0], "locks_can": [False, False], "locks_cit": [False, False, False] }); add key/value pair to dictionary; push result ({ "candidates": [0, 0], "citizens": [{ "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }], "locks_can": [False, False], "locks_cit": [False, False, False] })
  source code:       .locks_can:[Lock(),]*n,
  stack:             [{:}, 21042, { "result": None }, { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }]

Step 102:
  program counter:   977
  hvm code:          StoreVar result
  explanation:       pop value ({ "candidates": [0, 0], "citizens": [{ "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }], "locks_can": [False, False], "locks_cit": [False, False, False] }) and store locally in variable "result"
  source code:       result = {
  method variables:  { result: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] } }
  stack:             [{:}, 21042, { "result": None }]

Step 103:
  program counter:   978
  hvm code:          Return
  explanation:       push result ({ "candidates": [0, 0], "citizens": [{ "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }], "locks_can": [False, False], "locks_cit": [False, False, False] }) and restore method variables
  start statement:   line=4 column=1
  end statement:     line=4 column=19
  source code:       def Election(n, m):
                     ^^^^^^^^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        __init__()
  stack:             [{:}, { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }]

Step 104:
  program counter:   1315
  hvm code:          Store e
  explanation:       pop value ({ "candidates": [0, 0], "citizens": [{ "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }], "locks_can": [False, False], "locks_cit": [False, False, False] }) and store into variable e
  file:              electiontest.hny
  start statement:   line=12 column=1
  end statement:     line=12 column=51
  source code:       e = election.Election(NUM_CANDIDATES, NUM_CITIZENS)
                     ^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}]

Step 105:
  program counter:   1316
  hvm code:          Jump 1455
  explanation:       jump over method definition: set program counter to 1455
  start statement:   line=14 column=1
  end statement:     line=14 column=15
  source code:       def complete():
                     ^^^

Step 106:
  program counter:   1455
  hvm code:          Push PC(1326)
  explanation:       push program counter constant 1326 ("test_vote")
  start statement:   line=39 column=1
  end statement:     line=39 column=25
  source code:       spawn test_vote(?e, 0, 0)
                           ^^^^^^^^^
  stack:             [{:}, PC(1326)]

Step 107:
  program counter:   1456
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn test_vote(?e, 0, 0)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), []]

Step 108:
  program counter:   1457
  hvm code:          Push ?e
  explanation:       push constant ?e
  source code:       spawn test_vote(?e, 0, 0)
                                      ^
  stack:             [{:}, PC(1326), [], ?e]

Step 109:
  program counter:   1458
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       spawn test_vote(?e, 0, 0)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e ]]

Step 110:
  program counter:   1459
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       spawn test_vote(?e, 0, 0)
                                         ^
  stack:             [{:}, PC(1326), [ ?e ], 0]

Step 111:
  program counter:   1460
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [?e]); insert first value into the second; push result ([?e, 0])
  source code:       spawn test_vote(?e, 0, 0)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e, 0 ]]

Step 112:
  program counter:   1461
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       spawn test_vote(?e, 0, 0)
                                            ^
  stack:             [{:}, PC(1326), [ ?e, 0 ], 0]

Step 113:
  program counter:   1462
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [?e, 0]); insert first value into the second; push result ([?e, 0, 0])
  source code:       spawn test_vote(?e, 0, 0)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e, 0, 0 ]]

Step 114:
  program counter:   1463
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn test_vote(?e, 0, 0)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e, 0, 0 ], {:}]

Step 115:
  program counter:   1464
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([?e, 0, 0]), and program counter (1326: "test_vote"), and spawn thread
  start expression:  line=39 column=1
  end expression:    line=39 column=25
  stack:             [{:}]

Step 116:
  program counter:   1465
  hvm code:          Push PC(1326)
  explanation:       push program counter constant 1326 ("test_vote")
  start statement:   line=40 column=1
  end statement:     line=40 column=25
  source code:       spawn test_vote(?e, 1, 1)
                           ^^^^^^^^^
  stack:             [{:}, PC(1326)]

Step 117:
  program counter:   1466
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn test_vote(?e, 1, 1)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), []]

Step 118:
  program counter:   1467
  hvm code:          Push ?e
  explanation:       push constant ?e
  source code:       spawn test_vote(?e, 1, 1)
                                      ^
  stack:             [{:}, PC(1326), [], ?e]

Step 119:
  program counter:   1468
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       spawn test_vote(?e, 1, 1)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e ]]

Step 120:
  program counter:   1469
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       spawn test_vote(?e, 1, 1)
                                         ^
  stack:             [{:}, PC(1326), [ ?e ], 1]

Step 121:
  program counter:   1470
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e]); insert first value into the second; push result ([?e, 1])
  source code:       spawn test_vote(?e, 1, 1)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e, 1 ]]

Step 122:
  program counter:   1471
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       spawn test_vote(?e, 1, 1)
                                            ^
  stack:             [{:}, PC(1326), [ ?e, 1 ], 1]

Step 123:
  program counter:   1472
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e, 1]); insert first value into the second; push result ([?e, 1, 1])
  source code:       spawn test_vote(?e, 1, 1)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e, 1, 1 ]]

Step 124:
  program counter:   1473
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn test_vote(?e, 1, 1)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e, 1, 1 ], {:}]

Step 125:
  program counter:   1474
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([?e, 1, 1]), and program counter (1326: "test_vote"), and spawn thread
  start expression:  line=40 column=1
  end expression:    line=40 column=25
  stack:             [{:}]

Step 126:
  program counter:   1475
  hvm code:          Push PC(1326)
  explanation:       push program counter constant 1326 ("test_vote")
  start statement:   line=41 column=1
  end statement:     line=41 column=25
  source code:       spawn test_vote(?e, 1, 1)
                           ^^^^^^^^^
  stack:             [{:}, PC(1326)]

Step 127:
  program counter:   1476
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn test_vote(?e, 1, 1)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), []]

Step 128:
  program counter:   1477
  hvm code:          Push ?e
  explanation:       push constant ?e
  source code:       spawn test_vote(?e, 1, 1)
                                      ^
  stack:             [{:}, PC(1326), [], ?e]

Step 129:
  program counter:   1478
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       spawn test_vote(?e, 1, 1)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e ]]

Step 130:
  program counter:   1479
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       spawn test_vote(?e, 1, 1)
                                         ^
  stack:             [{:}, PC(1326), [ ?e ], 1]

Step 131:
  program counter:   1480
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e]); insert first value into the second; push result ([?e, 1])
  source code:       spawn test_vote(?e, 1, 1)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e, 1 ]]

Step 132:
  program counter:   1481
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       spawn test_vote(?e, 1, 1)
                                            ^
  stack:             [{:}, PC(1326), [ ?e, 1 ], 1]

Step 133:
  program counter:   1482
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e, 1]); insert first value into the second; push result ([?e, 1, 1])
  source code:       spawn test_vote(?e, 1, 1)
                                     ^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e, 1, 1 ]]

Step 134:
  program counter:   1483
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn test_vote(?e, 1, 1)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1326), [ ?e, 1, 1 ], {:}]

Step 135:
  program counter:   1484
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([?e, 1, 1]), and program counter (1326: "test_vote"), and spawn thread
  start expression:  line=41 column=1
  end expression:    line=41 column=25
  stack:             [{:}]

Step 136:
  program counter:   1485
  hvm code:          Push PC(1346)
  explanation:       push program counter constant 1346 ("test_withdraw")
  start statement:   line=42 column=1
  end statement:     line=42 column=32
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                           ^^^^^^^^^^^^^
  stack:             [{:}, PC(1346)]

Step 137:
  program counter:   1486
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                                         ^^^^^^^^^^^
  stack:             [{:}, PC(1346), []]

Step 138:
  program counter:   1487
  hvm code:          Push ?e
  explanation:       push constant ?e
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                                          ^
  stack:             [{:}, PC(1346), [], ?e]

Step 139:
  program counter:   1488
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                                         ^^^^^^^^^^^
  stack:             [{:}, PC(1346), [ ?e ]]

Step 140:
  program counter:   1489
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                                             ^
  stack:             [{:}, PC(1346), [ ?e ], 0]

Step 141:
  program counter:   1490
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [?e]); insert first value into the second; push result ([?e, 0])
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                                         ^^^^^^^^^^^
  stack:             [{:}, PC(1346), [ ?e, 0 ]]

Step 142:
  program counter:   1491
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                                                ^
  stack:             [{:}, PC(1346), [ ?e, 0 ], 1]

Step 143:
  program counter:   1492
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e, 0]); insert first value into the second; push result ([?e, 0, 1])
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                                         ^^^^^^^^^^^
  stack:             [{:}, PC(1346), [ ?e, 0, 1 ]]

Step 144:
  program counter:   1493
  hvm code:          Push 2
  explanation:       push constant 2
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                                                   ^
  stack:             [{:}, PC(1346), [ ?e, 0, 1 ], 2]

Step 145:
  program counter:   1494
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, [?e, 0, 1]); insert first value into the second; push result ([?e, 0, 1, 2])
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                                         ^^^^^^^^^^^
  stack:             [{:}, PC(1346), [ ?e, 0, 1, 2 ]]

Step 146:
  program counter:   1495
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn test_withdraw(?e, 0, 1, 2)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1346), [ ?e, 0, 1, 2 ], {:}]

Step 147:
  program counter:   1496
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([?e, 0, 1, 2]), and program counter (1346: "test_withdraw"), and spawn thread
  start expression:  line=42 column=1
  end expression:    line=42 column=32
  stack:             [{:}]

Step 148:
  program counter:   1497
  hvm code:          Push PC(1385)
  explanation:       push program counter constant 1385 ("end_test")
  start statement:   line=44 column=1
  end statement:     line=44 column=16
  source code:       spawn end_test()
                           ^^^^^^^^
  stack:             [{:}, PC(1385)]

Step 149:
  program counter:   1498
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       spawn end_test()
                                   ^^
  stack:             [{:}, PC(1385), []]

Step 150:
  program counter:   1499
  hvm code:          Push {:}
  explanation:       push constant {:}
  source code:       spawn end_test()
                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1385), [], {:}]

Step 151:
  program counter:   1500
  hvm code:          Spawn
  explanation:       pop thread-local state ({:}), argument ([]), and program counter (1385: "end_test"), and spawn thread
  start expression:  line=44 column=1
  end expression:    line=44 column=16
  stack:             [{:}]

Step 152:
  program counter:   1501
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=1 column=1
  end statement:     line=44 column=23
  source code:       from synch import Lock, acquire, release
  method variables:  { }
  new mode:          terminated
  stack:             []

================================================
Running thread T4: test_withdraw(?e, 0, 1, 2)
mode:  runnable
stack: ['[ ?e, 0, 1, 2 ]']
other threads:
  T0: pc=1501 terminated atomic __init__()
  T1: pc=1326 runnable test_vote(?e, 0, 0)
  T2: pc=1326 runnable test_vote(?e, 1, 1)
  T3: pc=1326 runnable test_vote(?e, 1, 1)
  T5: pc=1385 runnable end_test()
shared variables:
  EXPECTED_VOTES: [ 3, 0 ]
  NUM_CANDIDATES: 2
  NUM_CITIZENS: 3
  WINNER: 0
  e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }
  number_of_spawned_threads: 4
  threads_executed: 0
state id: 3
================================================

Step 153:
  program counter:   1346
  hvm code:          Frame test_withdraw(e, first_candidate, second_candidate, citizen_idx)
  explanation:       method "test_withdraw" with argument (e, first_candidate, second_candidate, citizen_idx) set to [?e, 0, 1, 2]
  start statement:   line=22 column=1
  end statement:     line=22 column=69
  source code:       def test_withdraw(e, first_candidate, second_candidate, citizen_idx):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { citizen_idx: 2, e: ?e, first_candidate: 0, result: None, second_candidate: 1 }
  call trace:        test_withdraw(?e, 0, 1, 2)
  stack:             [{:}]

Step 154:
  program counter:   1347
  hvm code:          Push PC(980)
  explanation:       push program counter constant 980 ("vote")
  start statement:   line=23 column=5
  end statement:     line=23 column=50
  source code:       election.vote(e, first_candidate, citizen_idx)
                     ^^^^^^^^^^^^^
  stack:             [{:}, PC(980)]

Step 155:
  program counter:   1348
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       election.vote(e, first_candidate, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), []]

Step 156:
  program counter:   1349
  hvm code:          LoadVar e
  explanation:       push value (?e) of variable "e"
  source code:       election.vote(e, first_candidate, citizen_idx)
                                   ^
  stack:             [{:}, PC(980), [], ?e]

Step 157:
  program counter:   1350
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       election.vote(e, first_candidate, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ]]

Step 158:
  program counter:   1351
  hvm code:          LoadVar first_candidate
  explanation:       push value (0) of variable "first_candidate"
  source code:       election.vote(e, first_candidate, citizen_idx)
                                      ^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ], 0]

Step 159:
  program counter:   1352
  hvm code:          DelVar first_candidate
  explanation:       delete method variable first_candidate
  start expression:  line=23 column=22
  end expression:    line=23 column=36
  method variables:  { citizen_idx: 2, e: ?e, result: None, second_candidate: 1 }

Step 160:
  program counter:   1353
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [?e]); insert first value into the second; push result ([?e, 0])
  source code:       election.vote(e, first_candidate, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 0 ]]

Step 161:
  program counter:   1354
  hvm code:          LoadVar citizen_idx
  explanation:       push value (2) of variable "citizen_idx"
  source code:       election.vote(e, first_candidate, citizen_idx)
                                                       ^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 0 ], 2]

Step 162:
  program counter:   1355
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, [?e, 0]); insert first value into the second; push result ([?e, 0, 2])
  source code:       election.vote(e, first_candidate, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 0, 2 ]]

Step 163:
  program counter:   1356
  hvm code:          Apply
  explanation:       pop an argument ([?e, 0, 2]) and a program counter value (980: "vote") and call the method
  source code:       election.vote(e, first_candidate, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, [ ?e, 0, 2 ]]

Step 164:
  program counter:   980
  hvm code:          Frame vote(election, candidate, citizen)
  explanation:       method "vote" with argument (election, candidate, citizen) set to [?e, 0, 2]
  file:              electionimpl.hny
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e, result: None }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 165:
  program counter:   981
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e }

Step 166:
  program counter:   982
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start expression:  line=16 column=5
  end expression:    line=16 column=11
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695)]

Step 167:
  program counter:   983
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e]

Step 168:
  program counter:   984
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e, "locks_can"]

Step 169:
  program counter:   985
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_can"]]

Step 170:
  program counter:   986
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       acquire(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_can"], 0]

Step 171:
  program counter:   987
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_can"][0]]

Step 172:
  program counter:   988
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2) --> acquire(?e["locks_can"][0])
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15826, ?e["locks_can"][0]]

Step 173:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15826, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 174:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2) --> acquire(?e["locks_can"][0])

Step 175:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 176:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15826, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_can"][0]]

Step 177:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15826, { "candidate": 0, "citizen": 2, "election": ?e }, False]

Step 178:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15826, { "candidate": 0, "citizen": 2, "election": ?e }, True]

Step 179:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15826, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 180:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 181:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 182:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15826, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_can"][0]]

Step 183:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 184:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15826, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_can"][0], True]

Step 185:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][0]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15826, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 186:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 187:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 188:
  program counter:   989
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 189:
  program counter:   990
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695)]

Step 190:
  program counter:   991
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e]

Step 191:
  program counter:   992
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       acquire(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e, "locks_cit"]

Step 192:
  program counter:   993
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_cit"]]

Step 193:
  program counter:   994
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       acquire(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_cit"], 2]

Step 194:
  program counter:   995
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][2])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_cit"][2]]

Step 195:
  program counter:   996
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][2]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2) --> acquire(?e["locks_cit"][2])
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15954, ?e["locks_cit"][2]]

Step 196:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_cit"][2]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][2], result: None }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15954, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 197:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2) --> acquire(?e["locks_cit"][2])

Step 198:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 199:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15954, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 200:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][2]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15954, { "candidate": 0, "citizen": 2, "election": ?e }, False]

Step 201:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15954, { "candidate": 0, "citizen": 2, "election": ?e }, True]

Step 202:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15954, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 203:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 204:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 205:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15954, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 206:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 207:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15954, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_cit"][2], True]

Step 208:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_cit"][2]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 15954, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 209:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 210:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 211:
  program counter:   997
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 212:
  program counter:   998
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=20 column=5
  end statement:     line=20 column=50
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e]

Step 213:
  program counter:   999
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       if election->citizens[citizen].voted == False:
                                  ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e, "citizens"]

Step 214:
  program counter:   1000
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"]]

Step 215:
  program counter:   1001
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       if election->citizens[citizen].voted == False:
                                           ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"], 2]

Step 216:
  program counter:   1002
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]]

Step 217:
  program counter:   1003
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       if election->citizens[citizen].voted == False:
                                                   ^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2], "voted"]

Step 218:
  program counter:   1004
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted"]]

Step 219:
  program counter:   1005
  hvm code:          Load
  explanation:       pop address of variable (?e["citizens"][2]["voted"]) and push value (False)
  start expression:  line=20 column=8
  end expression:    line=20 column=40
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, False]

Step 220:
  program counter:   1006
  hvm code:          Push False
  explanation:       push constant False
  source code:       if election->citizens[citizen].voted == False:
                                                             ^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, False, False]

Step 221:
  program counter:   1007
  hvm code:          2-ary ==
  explanation:       pop 2 values (False, False); check if both values are the same; push result (True)
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, True]

Step 222:
  program counter:   1008
  hvm code:          JumpCond False 1039
  explanation:       pop value (True), compare to False, and jump to 1039 if the same
  source code:       if election->citizens[citizen].voted == False:
                     ^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 223:
  program counter:   1009
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=21 column=9
  end statement:     line=21 column=44
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e]

Step 224:
  program counter:   1010
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       election->candidates[candidate] += 1
                               ^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e, "candidates"]

Step 225:
  program counter:   1011
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"]]

Step 226:
  program counter:   1012
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       election->candidates[candidate] += 1
                                          ^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"], 0]

Step 227:
  program counter:   1013
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["candidates"]) and push the combined address (?e["candidates"][0])
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0]]

Step 228:
  program counter:   1014
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0], ?e["candidates"][0]]

Step 229:
  program counter:   1015
  hvm code:          Load
  explanation:       pop address of variable (?e["candidates"][0]) and push value (0)
  start expression:  line=21 column=9
  end expression:    line=21 column=44
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0], 0]

Step 230:
  program counter:   1016
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       election->candidates[candidate] += 1
                                                        ^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0], 0, 1]

Step 231:
  program counter:   1017
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0], 1]

Step 232:
  program counter:   1018
  hvm code:          Store
  explanation:       pop value (1) and address (?e["candidates"][0]) and store
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 233:
  program counter:   1019
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=22 column=9
  end statement:     line=22 column=48
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e]

Step 234:
  program counter:   1020
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted = True
                               ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e, "citizens"]

Step 235:
  program counter:   1021
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"]]

Step 236:
  program counter:   1022
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       election->citizens[citizen].voted = True
                                        ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"], 2]

Step 237:
  program counter:   1023
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]]

Step 238:
  program counter:   1024
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       election->citizens[citizen].voted = True
                                                ^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2], "voted"]

Step 239:
  program counter:   1025
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted"])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted"]]

Step 240:
  program counter:   1026
  hvm code:          Push True
  explanation:       push constant True
  source code:       election->citizens[citizen].voted = True
                                                         ^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted"], True]

Step 241:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value (True) and address (?e["citizens"][2]["voted"]) and store
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": -1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 242:
  program counter:   1028
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=23 column=9
  end statement:     line=23 column=57
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e]

Step 243:
  program counter:   1029
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted_for = candidate
                               ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e, "citizens"]

Step 244:
  program counter:   1030
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"]]

Step 245:
  program counter:   1031
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       election->citizens[citizen].voted_for = candidate
                                        ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"], 2]

Step 246:
  program counter:   1032
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]]

Step 247:
  program counter:   1033
  hvm code:          Push "voted_for"
  explanation:       push constant "voted_for"
  source code:       election->citizens[citizen].voted_for = candidate
                                                ^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2], "voted_for"]

Step 248:
  program counter:   1034
  hvm code:          Address
  explanation:       pop a key ("voted_for") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted_for"])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted_for"]]

Step 249:
  program counter:   1035
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       election->citizens[citizen].voted_for = candidate
                                                             ^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted_for"], 0]

Step 250:
  program counter:   1036
  hvm code:          Store
  explanation:       pop value (0) and address (?e["citizens"][2]["voted_for"]) and store
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 0 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 251:
  program counter:   1037
  hvm code:          Push True
  explanation:       push constant True
  start statement:   line=24 column=9
  end statement:     line=24 column=21
  source code:       result = True
                              ^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, True]

Step 252:
  program counter:   1038
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = True
                     ^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e, result: True }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 253:
  program counter:   1039
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=18
  source code:       result = False
                              ^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e }

Step 254:
  program counter:   1040
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=25 column=14
  end expression:    line=25 column=18
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, False]

Step 255:
  program counter:   1041
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = False
                     ^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e, result: False }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 256:
  program counter:   1042
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714)]

Step 257:
  program counter:   1043
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e]

Step 258:
  program counter:   1044
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       release(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e, "locks_cit"]

Step 259:
  program counter:   1045
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_cit"]]

Step 260:
  program counter:   1046
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       release(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_cit"], 2]

Step 261:
  program counter:   1047
  hvm code:          DelVar citizen
  explanation:       delete method variable citizen
  start expression:  line=28 column=35
  end expression:    line=28 column=41
  method variables:  { candidate: 0, election: ?e, result: False }

Step 262:
  program counter:   1048
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][2])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_cit"][2]]

Step 263:
  program counter:   1049
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][2]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2) --> release(?e["locks_cit"][2])
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16802, ?e["locks_cit"][2]]

Step 264:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_cit"][2]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][2], result: None }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16802, { "candidate": 0, "election": ?e, "result": False }]

Step 265:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2) --> release(?e["locks_cit"][2])

Step 266:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 267:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 268:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16802, { "candidate": 0, "election": ?e, "result": False }, ?e["locks_cit"][2]]

Step 269:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][2]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16802, { "candidate": 0, "election": ?e, "result": False }, True]

Step 270:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16802, { "candidate": 0, "election": ?e, "result": False }]

Step 271:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 272:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 273:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16802, { "candidate": 0, "election": ?e, "result": False }, ?e["locks_cit"][2]]

Step 274:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 275:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16802, { "candidate": 0, "election": ?e, "result": False }, ?e["locks_cit"][2], False]

Step 276:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_cit"][2]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 0 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16802, { "candidate": 0, "election": ?e, "result": False }]

Step 277:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 278:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, election: ?e, result: False }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 279:
  program counter:   1050
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 280:
  program counter:   1051
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714)]

Step 281:
  program counter:   1052
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e]

Step 282:
  program counter:   1053
  hvm code:          DelVar election
  explanation:       delete method variable election
  start expression:  line=29 column=15
  end expression:    line=29 column=22
  method variables:  { candidate: 0, result: False }

Step 283:
  program counter:   1054
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e, "locks_can"]

Step 284:
  program counter:   1055
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_can"]]

Step 285:
  program counter:   1056
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       release(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_can"], 0]

Step 286:
  program counter:   1057
  hvm code:          DelVar candidate
  explanation:       delete method variable candidate
  start expression:  line=29 column=35
  end expression:    line=29 column=43
  method variables:  { result: False }

Step 287:
  program counter:   1058
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_can"][0]]

Step 288:
  program counter:   1059
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2) --> release(?e["locks_can"][0])
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16962, ?e["locks_can"][0]]

Step 289:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16962, { "result": False }]

Step 290:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2) --> release(?e["locks_can"][0])

Step 291:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 292:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 293:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16962, { "result": False }, ?e["locks_can"][0]]

Step 294:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16962, { "result": False }, True]

Step 295:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16962, { "result": False }]

Step 296:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 297:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 298:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16962, { "result": False }, ?e["locks_can"][0]]

Step 299:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 300:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16962, { "result": False }, ?e["locks_can"][0], False]

Step 301:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][0]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 0 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 16962, { "result": False }]

Step 302:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 303:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: False }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 0, 2)
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 304:
  program counter:   1060
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21714, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 305:
  program counter:   1061
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { citizen_idx: 2, e: ?e, result: None, second_candidate: 1 }
  call trace:        test_withdraw(?e, 0, 1, 2)
  stack:             [{:}, False]

Step 306:
  program counter:   1357
  hvm code:          Pop
  explanation:       pop and discard value (False)
  file:              electiontest.hny
  start statement:   line=23 column=5
  end statement:     line=23 column=50
  source code:       election.vote(e, first_candidate, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 307:
  program counter:   1358
  hvm code:          Push PC(1063)
  explanation:       push program counter constant 1063 ("withdraw")
  start statement:   line=24 column=5
  end statement:     line=24 column=37
  source code:       election.withdraw(e, citizen_idx)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1063)]

Step 308:
  program counter:   1359
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       election.withdraw(e, citizen_idx)
                                       ^^^^^^^^^^^^^^
  stack:             [{:}, PC(1063), []]

Step 309:
  program counter:   1360
  hvm code:          LoadVar e
  explanation:       push value (?e) of variable "e"
  source code:       election.withdraw(e, citizen_idx)
                                       ^
  stack:             [{:}, PC(1063), [], ?e]

Step 310:
  program counter:   1361
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       election.withdraw(e, citizen_idx)
                                       ^^^^^^^^^^^^^^
  stack:             [{:}, PC(1063), [ ?e ]]

Step 311:
  program counter:   1362
  hvm code:          LoadVar citizen_idx
  explanation:       push value (2) of variable "citizen_idx"
  source code:       election.withdraw(e, citizen_idx)
                                          ^^^^^^^^^^^
  stack:             [{:}, PC(1063), [ ?e ], 2]

Step 312:
  program counter:   1363
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, [?e]); insert first value into the second; push result ([?e, 2])
  source code:       election.withdraw(e, citizen_idx)
                                       ^^^^^^^^^^^^^^
  stack:             [{:}, PC(1063), [ ?e, 2 ]]

Step 313:
  program counter:   1364
  hvm code:          Apply
  explanation:       pop an argument ([?e, 2]) and a program counter value (1063: "withdraw") and call the method
  source code:       election.withdraw(e, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, [ ?e, 2 ]]

Step 314:
  program counter:   1063
  hvm code:          Frame withdraw(election, citizen)
  explanation:       method "withdraw" with argument (election, citizen) set to [?e, 2]
  file:              electionimpl.hny
  start statement:   line=32 column=1
  end statement:     line=32 column=32
  source code:       def withdraw(election, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { citizen: 2, election: ?e, result: None }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 315:
  program counter:   1064
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=34 column=5
  end statement:     line=34 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^
  method variables:  { citizen: 2, election: ?e }

Step 316:
  program counter:   1065
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start expression:  line=34 column=5
  end expression:    line=34 column=11
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695)]

Step 317:
  program counter:   1066
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e]

Step 318:
  program counter:   1067
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       acquire(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e, "locks_cit"]

Step 319:
  program counter:   1068
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_cit"]]

Step 320:
  program counter:   1069
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       acquire(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_cit"], 2]

Step 321:
  program counter:   1070
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][2])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_cit"][2]]

Step 322:
  program counter:   1071
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][2]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> acquire(?e["locks_cit"][2])
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17154, ?e["locks_cit"][2]]

Step 323:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_cit"][2]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][2], result: None }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17154, { "citizen": 2, "election": ?e }]

Step 324:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> acquire(?e["locks_cit"][2])

Step 325:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 326:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17154, { "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 327:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][2]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17154, { "citizen": 2, "election": ?e }, False]

Step 328:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17154, { "citizen": 2, "election": ?e }, True]

Step 329:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17154, { "citizen": 2, "election": ?e }]

Step 330:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 331:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 332:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17154, { "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 333:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 334:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17154, { "citizen": 2, "election": ?e }, ?e["locks_cit"][2], True]

Step 335:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_cit"][2]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 0 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17154, { "citizen": 2, "election": ?e }]

Step 336:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 337:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { citizen: 2, election: ?e }
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 338:
  program counter:   1072
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=34 column=5
  end statement:     line=34 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 339:
  program counter:   1073
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=35 column=5
  end statement:     line=35 column=57
  source code:       var candidate = election->citizens[citizen].voted_for
                                     ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e]

Step 340:
  program counter:   1074
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       var candidate = election->citizens[citizen].voted_for
                                               ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e, "citizens"]

Step 341:
  program counter:   1075
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       var candidate = election->citizens[citizen].voted_for
                                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"]]

Step 342:
  program counter:   1076
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       var candidate = election->citizens[citizen].voted_for
                                                        ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"], 2]

Step 343:
  program counter:   1077
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       var candidate = election->citizens[citizen].voted_for
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]]

Step 344:
  program counter:   1078
  hvm code:          Push "voted_for"
  explanation:       push constant "voted_for"
  source code:       var candidate = election->citizens[citizen].voted_for
                                                                ^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2], "voted_for"]

Step 345:
  program counter:   1079
  hvm code:          Address
  explanation:       pop a key ("voted_for") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted_for"])
  source code:       var candidate = election->citizens[citizen].voted_for
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted_for"]]

Step 346:
  program counter:   1080
  hvm code:          Load
  explanation:       pop address of variable (?e["citizens"][2]["voted_for"]) and push value (0)
  start expression:  line=35 column=21
  end expression:    line=35 column=57
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 0]

Step 347:
  program counter:   1081
  hvm code:          StoreVar candidate
  explanation:       pop value (0) and store locally in variable "candidate"
  source code:       var candidate = election->citizens[citizen].voted_for
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 348:
  program counter:   1082
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=36 column=5
  end statement:     line=36 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714)]

Step 349:
  program counter:   1083
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e]

Step 350:
  program counter:   1084
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       release(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e, "locks_cit"]

Step 351:
  program counter:   1085
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_cit"]]

Step 352:
  program counter:   1086
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       release(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_cit"], 2]

Step 353:
  program counter:   1087
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][2])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_cit"][2]]

Step 354:
  program counter:   1088
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][2]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> release(?e["locks_cit"][2])
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17426, ?e["locks_cit"][2]]

Step 355:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_cit"][2]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][2], result: None }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17426, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 356:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> release(?e["locks_cit"][2])

Step 357:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 358:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 359:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17426, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 360:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][2]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17426, { "candidate": 0, "citizen": 2, "election": ?e }, True]

Step 361:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17426, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 362:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 363:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 364:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17426, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 365:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 366:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17426, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_cit"][2], False]

Step 367:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_cit"][2]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 0 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17426, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 368:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 369:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e }
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 370:
  program counter:   1089
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=36 column=5
  end statement:     line=36 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 371:
  program counter:   1090
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=39 column=5
  end statement:     line=39 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695)]

Step 372:
  program counter:   1091
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e]

Step 373:
  program counter:   1092
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e, "locks_can"]

Step 374:
  program counter:   1093
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_can"]]

Step 375:
  program counter:   1094
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       acquire(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_can"], 0]

Step 376:
  program counter:   1095
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_can"][0]]

Step 377:
  program counter:   1096
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> acquire(?e["locks_can"][0])
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17554, ?e["locks_can"][0]]

Step 378:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17554, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 379:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> acquire(?e["locks_can"][0])

Step 380:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 381:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17554, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_can"][0]]

Step 382:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17554, { "candidate": 0, "citizen": 2, "election": ?e }, False]

Step 383:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17554, { "candidate": 0, "citizen": 2, "election": ?e }, True]

Step 384:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17554, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 385:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 386:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 387:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17554, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_can"][0]]

Step 388:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 389:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17554, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_can"][0], True]

Step 390:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][0]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 0 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17554, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 391:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 392:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e }
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 393:
  program counter:   1097
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=39 column=5
  end statement:     line=39 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 394:
  program counter:   1098
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=40 column=5
  end statement:     line=40 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695)]

Step 395:
  program counter:   1099
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e]

Step 396:
  program counter:   1100
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       acquire(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e, "locks_cit"]

Step 397:
  program counter:   1101
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_cit"]]

Step 398:
  program counter:   1102
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       acquire(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_cit"], 2]

Step 399:
  program counter:   1103
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][2])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(695), ?e["locks_cit"][2]]

Step 400:
  program counter:   1104
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][2]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> acquire(?e["locks_cit"][2])
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17682, ?e["locks_cit"][2]]

Step 401:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_cit"][2]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][2], result: None }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17682, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 402:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> acquire(?e["locks_cit"][2])

Step 403:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 404:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17682, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 405:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][2]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17682, { "candidate": 0, "citizen": 2, "election": ?e }, False]

Step 406:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17682, { "candidate": 0, "citizen": 2, "election": ?e }, True]

Step 407:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17682, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 408:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 409:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 410:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17682, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 411:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 412:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17682, { "candidate": 0, "citizen": 2, "election": ?e }, ?e["locks_cit"][2], True]

Step 413:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_cit"][2]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 0 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 17682, { "candidate": 0, "citizen": 2, "election": ?e }]

Step 414:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 415:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e }
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 416:
  program counter:   1105
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=40 column=5
  end statement:     line=40 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 417:
  program counter:   1106
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=43 column=5
  end statement:     line=43 column=49
  source code:       if election->citizens[citizen].voted == True:
                        ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e]

Step 418:
  program counter:   1107
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       if election->citizens[citizen].voted == True:
                                  ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e, "citizens"]

Step 419:
  program counter:   1108
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       if election->citizens[citizen].voted == True:
                        ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"]]

Step 420:
  program counter:   1109
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       if election->citizens[citizen].voted == True:
                                           ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"], 2]

Step 421:
  program counter:   1110
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       if election->citizens[citizen].voted == True:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]]

Step 422:
  program counter:   1111
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       if election->citizens[citizen].voted == True:
                                                   ^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2], "voted"]

Step 423:
  program counter:   1112
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted"])
  source code:       if election->citizens[citizen].voted == True:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted"]]

Step 424:
  program counter:   1113
  hvm code:          Load
  explanation:       pop address of variable (?e["citizens"][2]["voted"]) and push value (True)
  start expression:  line=43 column=8
  end expression:    line=43 column=40
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, True]

Step 425:
  program counter:   1114
  hvm code:          Push True
  explanation:       push constant True
  source code:       if election->citizens[citizen].voted == True:
                                                             ^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, True, True]

Step 426:
  program counter:   1115
  hvm code:          2-ary ==
  explanation:       pop 2 values (True, True); check if both values are the same; push result (True)
  source code:       if election->citizens[citizen].voted == True:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, True]

Step 427:
  program counter:   1116
  hvm code:          JumpCond False 1147
  explanation:       pop value (True), compare to False, and jump to 1147 if the same
  source code:       if election->citizens[citizen].voted == True:
                     ^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 428:
  program counter:   1117
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=44 column=9
  end statement:     line=44 column=44
  source code:       election->candidates[candidate] -= 1
                     ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e]

Step 429:
  program counter:   1118
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       election->candidates[candidate] -= 1
                               ^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e, "candidates"]

Step 430:
  program counter:   1119
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       election->candidates[candidate] -= 1
                     ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"]]

Step 431:
  program counter:   1120
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       election->candidates[candidate] -= 1
                                          ^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"], 0]

Step 432:
  program counter:   1121
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["candidates"]) and push the combined address (?e["candidates"][0])
  source code:       election->candidates[candidate] -= 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0]]

Step 433:
  program counter:   1122
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       election->candidates[candidate] -= 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0], ?e["candidates"][0]]

Step 434:
  program counter:   1123
  hvm code:          Load
  explanation:       pop address of variable (?e["candidates"][0]) and push value (1)
  start expression:  line=44 column=9
  end expression:    line=44 column=44
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0], 1]

Step 435:
  program counter:   1124
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       election->candidates[candidate] -= 1
                                                        ^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0], 1, 1]

Step 436:
  program counter:   1125
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 1); the second integer minus the first; push result (0)
  source code:       election->candidates[candidate] -= 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["candidates"][0], 0]

Step 437:
  program counter:   1126
  hvm code:          Store
  explanation:       pop value (0) and address (?e["candidates"][0]) and store
  source code:       election->candidates[candidate] -= 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 0 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 438:
  program counter:   1127
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=45 column=9
  end statement:     line=45 column=49
  source code:       election->citizens[citizen].voted = False
                     ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e]

Step 439:
  program counter:   1128
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted = False
                               ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e, "citizens"]

Step 440:
  program counter:   1129
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted = False
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"]]

Step 441:
  program counter:   1130
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       election->citizens[citizen].voted = False
                                        ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"], 2]

Step 442:
  program counter:   1131
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       election->citizens[citizen].voted = False
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]]

Step 443:
  program counter:   1132
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       election->citizens[citizen].voted = False
                                                ^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2], "voted"]

Step 444:
  program counter:   1133
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted"])
  source code:       election->citizens[citizen].voted = False
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted"]]

Step 445:
  program counter:   1134
  hvm code:          Push False
  explanation:       push constant False
  source code:       election->citizens[citizen].voted = False
                                                         ^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted"], False]

Step 446:
  program counter:   1135
  hvm code:          Store
  explanation:       pop value (False) and address (?e["citizens"][2]["voted"]) and store
  source code:       election->citizens[citizen].voted = False
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": 0 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 447:
  program counter:   1136
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=46 column=9
  end statement:     line=46 column=50
  source code:       election->citizens[citizen].voted_for = -1
                     ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e]

Step 448:
  program counter:   1137
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted_for = -1
                               ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e, "citizens"]

Step 449:
  program counter:   1138
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted_for = -1
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"]]

Step 450:
  program counter:   1139
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       election->citizens[citizen].voted_for = -1
                                        ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"], 2]

Step 451:
  program counter:   1140
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       election->citizens[citizen].voted_for = -1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]]

Step 452:
  program counter:   1141
  hvm code:          Push "voted_for"
  explanation:       push constant "voted_for"
  source code:       election->citizens[citizen].voted_for = -1
                                                ^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2], "voted_for"]

Step 453:
  program counter:   1142
  hvm code:          Address
  explanation:       pop a key ("voted_for") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted_for"])
  source code:       election->citizens[citizen].voted_for = -1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted_for"]]

Step 454:
  program counter:   1143
  hvm code:          Push -1
  explanation:       push constant -1
  source code:       election->citizens[citizen].voted_for = -1
                                                             ^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, ?e["citizens"][2]["voted_for"], -1]

Step 455:
  program counter:   1144
  hvm code:          Store
  explanation:       pop value (-1) and address (?e["citizens"][2]["voted_for"]) and store
  source code:       election->citizens[citizen].voted_for = -1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 456:
  program counter:   1145
  hvm code:          Push True
  explanation:       push constant True
  start statement:   line=47 column=9
  end statement:     line=47 column=21
  source code:       result = True
                              ^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, True]

Step 457:
  program counter:   1146
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = True
                     ^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e, result: True }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 458:
  program counter:   1147
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=48 column=5
  end statement:     line=48 column=18
  source code:       result = False
                              ^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e }

Step 459:
  program counter:   1148
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=48 column=14
  end expression:    line=48 column=18
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, False]

Step 460:
  program counter:   1149
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = False
                     ^^^^^^^^
  method variables:  { candidate: 0, citizen: 2, election: ?e, result: False }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 461:
  program counter:   1150
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=51 column=5
  end statement:     line=51 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714)]

Step 462:
  program counter:   1151
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e]

Step 463:
  program counter:   1152
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       release(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e, "locks_cit"]

Step 464:
  program counter:   1153
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_cit"]]

Step 465:
  program counter:   1154
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       release(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_cit"], 2]

Step 466:
  program counter:   1155
  hvm code:          DelVar citizen
  explanation:       delete method variable citizen
  start expression:  line=51 column=35
  end expression:    line=51 column=41
  method variables:  { candidate: 0, election: ?e, result: False }

Step 467:
  program counter:   1156
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][2])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_cit"][2]]

Step 468:
  program counter:   1157
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][2]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> release(?e["locks_cit"][2])
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18530, ?e["locks_cit"][2]]

Step 469:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_cit"][2]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][2], result: None }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18530, { "candidate": 0, "election": ?e, "result": False }]

Step 470:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> release(?e["locks_cit"][2])

Step 471:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 472:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 473:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18530, { "candidate": 0, "election": ?e, "result": False }, ?e["locks_cit"][2]]

Step 474:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][2]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18530, { "candidate": 0, "election": ?e, "result": False }, True]

Step 475:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18530, { "candidate": 0, "election": ?e, "result": False }]

Step 476:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 477:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 478:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18530, { "candidate": 0, "election": ?e, "result": False }, ?e["locks_cit"][2]]

Step 479:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 480:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18530, { "candidate": 0, "election": ?e, "result": False }, ?e["locks_cit"][2], False]

Step 481:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_cit"][2]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18530, { "candidate": 0, "election": ?e, "result": False }]

Step 482:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 483:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, election: ?e, result: False }
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 484:
  program counter:   1158
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=51 column=5
  end statement:     line=51 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 485:
  program counter:   1159
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=52 column=5
  end statement:     line=52 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714)]

Step 486:
  program counter:   1160
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e]

Step 487:
  program counter:   1161
  hvm code:          DelVar election
  explanation:       delete method variable election
  start expression:  line=52 column=15
  end expression:    line=52 column=22
  method variables:  { candidate: 0, result: False }

Step 488:
  program counter:   1162
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e, "locks_can"]

Step 489:
  program counter:   1163
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_can"]]

Step 490:
  program counter:   1164
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       release(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_can"], 0]

Step 491:
  program counter:   1165
  hvm code:          DelVar candidate
  explanation:       delete method variable candidate
  start expression:  line=52 column=35
  end expression:    line=52 column=43
  method variables:  { result: False }

Step 492:
  program counter:   1166
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, PC(714), ?e["locks_can"][0]]

Step 493:
  program counter:   1167
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> release(?e["locks_can"][0])
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18690, ?e["locks_can"][0]]

Step 494:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18690, { "result": False }]

Step 495:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2) --> release(?e["locks_can"][0])

Step 496:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 497:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 498:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18690, { "result": False }, ?e["locks_can"][0]]

Step 499:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18690, { "result": False }, True]

Step 500:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18690, { "result": False }]

Step 501:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 502:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 503:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18690, { "result": False }, ?e["locks_can"][0]]

Step 504:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 505:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18690, { "result": False }, ?e["locks_can"][0], False]

Step 506:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][0]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, 18690, { "result": False }]

Step 507:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 508:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: False }
  call trace:        test_withdraw(?e, 0, 1, 2) --> withdraw(?e, 2)
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }, None]

Step 509:
  program counter:   1168
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=52 column=5
  end statement:     line=52 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21842, { "citizen_idx": 2, "e": ?e, "result": None, "second_candidate": 1 }]

Step 510:
  program counter:   1169
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=32 column=1
  end statement:     line=32 column=32
  source code:       def withdraw(election, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { citizen_idx: 2, e: ?e, result: None, second_candidate: 1 }
  call trace:        test_withdraw(?e, 0, 1, 2)
  stack:             [{:}, False]

Step 511:
  program counter:   1365
  hvm code:          Pop
  explanation:       pop and discard value (False)
  file:              electiontest.hny
  start statement:   line=24 column=5
  end statement:     line=24 column=37
  source code:       election.withdraw(e, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 512:
  program counter:   1366
  hvm code:          Push PC(980)
  explanation:       push program counter constant 980 ("vote")
  start statement:   line=25 column=5
  end statement:     line=25 column=51
  source code:       election.vote(e, second_candidate, citizen_idx)
                     ^^^^^^^^^^^^^
  stack:             [{:}, PC(980)]

Step 513:
  program counter:   1367
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       election.vote(e, second_candidate, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), []]

Step 514:
  program counter:   1368
  hvm code:          LoadVar e
  explanation:       push value (?e) of variable "e"
  source code:       election.vote(e, second_candidate, citizen_idx)
                                   ^
  stack:             [{:}, PC(980), [], ?e]

Step 515:
  program counter:   1369
  hvm code:          DelVar e
  explanation:       delete method variable e
  start expression:  line=25 column=19
  end expression:    line=25 column=19
  method variables:  { citizen_idx: 2, result: None, second_candidate: 1 }

Step 516:
  program counter:   1370
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       election.vote(e, second_candidate, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ]]

Step 517:
  program counter:   1371
  hvm code:          LoadVar second_candidate
  explanation:       push value (1) of variable "second_candidate"
  source code:       election.vote(e, second_candidate, citizen_idx)
                                      ^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ], 1]

Step 518:
  program counter:   1372
  hvm code:          DelVar second_candidate
  explanation:       delete method variable second_candidate
  start expression:  line=25 column=22
  end expression:    line=25 column=37
  method variables:  { citizen_idx: 2, result: None }

Step 519:
  program counter:   1373
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e]); insert first value into the second; push result ([?e, 1])
  source code:       election.vote(e, second_candidate, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 1 ]]

Step 520:
  program counter:   1374
  hvm code:          LoadVar citizen_idx
  explanation:       push value (2) of variable "citizen_idx"
  source code:       election.vote(e, second_candidate, citizen_idx)
                                                        ^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 1 ], 2]

Step 521:
  program counter:   1375
  hvm code:          DelVar citizen_idx
  explanation:       delete method variable citizen_idx
  start expression:  line=25 column=40
  end expression:    line=25 column=50
  method variables:  { result: None }

Step 522:
  program counter:   1376
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (2, [?e, 1]); insert first value into the second; push result ([?e, 1, 2])
  source code:       election.vote(e, second_candidate, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 1, 2 ]]

Step 523:
  program counter:   1377
  hvm code:          Apply
  explanation:       pop an argument ([?e, 1, 2]) and a program counter value (980: "vote") and call the method
  source code:       election.vote(e, second_candidate, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, [ ?e, 1, 2 ]]

Step 524:
  program counter:   980
  hvm code:          Frame vote(election, candidate, citizen)
  explanation:       method "vote" with argument (election, candidate, citizen) set to [?e, 1, 2]
  file:              electionimpl.hny
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, citizen: 2, election: ?e, result: None }
  stack:             [{:}, 22050, { "result": None }]

Step 525:
  program counter:   981
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^
  method variables:  { candidate: 1, citizen: 2, election: ?e }

Step 526:
  program counter:   982
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start expression:  line=16 column=5
  end expression:    line=16 column=11
  stack:             [{:}, 22050, { "result": None }, PC(695)]

Step 527:
  program counter:   983
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e]

Step 528:
  program counter:   984
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e, "locks_can"]

Step 529:
  program counter:   985
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e["locks_can"]]

Step 530:
  program counter:   986
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       acquire(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e["locks_can"], 1]

Step 531:
  program counter:   987
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e["locks_can"][1]]

Step 532:
  program counter:   988
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2) --> acquire(?e["locks_can"][1])
  stack:             [{:}, 22050, { "result": None }, 15826, ?e["locks_can"][1]]

Step 533:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, 22050, { "result": None }, 15826, { "candidate": 1, "citizen": 2, "election": ?e }]

Step 534:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2) --> acquire(?e["locks_can"][1])

Step 535:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 536:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15826, { "candidate": 1, "citizen": 2, "election": ?e }, ?e["locks_can"][1]]

Step 537:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15826, { "candidate": 1, "citizen": 2, "election": ?e }, False]

Step 538:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15826, { "candidate": 1, "citizen": 2, "election": ?e }, True]

Step 539:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15826, { "candidate": 1, "citizen": 2, "election": ?e }]

Step 540:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 541:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 542:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15826, { "candidate": 1, "citizen": 2, "election": ?e }, ?e["locks_can"][1]]

Step 543:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 544:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 22050, { "result": None }, 15826, { "candidate": 1, "citizen": 2, "election": ?e }, ?e["locks_can"][1], True]

Step 545:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][1]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 22050, { "result": None }, 15826, { "candidate": 1, "citizen": 2, "election": ?e }]

Step 546:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 547:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, citizen: 2, election: ?e }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, { "result": None }, None]

Step 548:
  program counter:   989
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }]

Step 549:
  program counter:   990
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695)]

Step 550:
  program counter:   991
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e]

Step 551:
  program counter:   992
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       acquire(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e, "locks_cit"]

Step 552:
  program counter:   993
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e["locks_cit"]]

Step 553:
  program counter:   994
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       acquire(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e["locks_cit"], 2]

Step 554:
  program counter:   995
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][2])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(695), ?e["locks_cit"][2]]

Step 555:
  program counter:   996
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][2]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2) --> acquire(?e["locks_cit"][2])
  stack:             [{:}, 22050, { "result": None }, 15954, ?e["locks_cit"][2]]

Step 556:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_cit"][2]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][2], result: None }
  stack:             [{:}, 22050, { "result": None }, 15954, { "candidate": 1, "citizen": 2, "election": ?e }]

Step 557:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2) --> acquire(?e["locks_cit"][2])

Step 558:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 559:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15954, { "candidate": 1, "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 560:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][2]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15954, { "candidate": 1, "citizen": 2, "election": ?e }, False]

Step 561:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15954, { "candidate": 1, "citizen": 2, "election": ?e }, True]

Step 562:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15954, { "candidate": 1, "citizen": 2, "election": ?e }]

Step 563:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 564:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 565:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 15954, { "candidate": 1, "citizen": 2, "election": ?e }, ?e["locks_cit"][2]]

Step 566:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 567:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 22050, { "result": None }, 15954, { "candidate": 1, "citizen": 2, "election": ?e }, ?e["locks_cit"][2], True]

Step 568:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_cit"][2]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 0 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 22050, { "result": None }, 15954, { "candidate": 1, "citizen": 2, "election": ?e }]

Step 569:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 570:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, citizen: 2, election: ?e }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, { "result": None }, None]

Step 571:
  program counter:   997
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }]

Step 572:
  program counter:   998
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=20 column=5
  end statement:     line=20 column=50
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e]

Step 573:
  program counter:   999
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       if election->citizens[citizen].voted == False:
                                  ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e, "citizens"]

Step 574:
  program counter:   1000
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"]]

Step 575:
  program counter:   1001
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       if election->citizens[citizen].voted == False:
                                           ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"], 2]

Step 576:
  program counter:   1002
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2]]

Step 577:
  program counter:   1003
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       if election->citizens[citizen].voted == False:
                                                   ^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2], "voted"]

Step 578:
  program counter:   1004
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2]["voted"]]

Step 579:
  program counter:   1005
  hvm code:          Load
  explanation:       pop address of variable (?e["citizens"][2]["voted"]) and push value (False)
  start expression:  line=20 column=8
  end expression:    line=20 column=40
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, { "result": None }, False]

Step 580:
  program counter:   1006
  hvm code:          Push False
  explanation:       push constant False
  source code:       if election->citizens[citizen].voted == False:
                                                             ^^^^^
  stack:             [{:}, 22050, { "result": None }, False, False]

Step 581:
  program counter:   1007
  hvm code:          2-ary ==
  explanation:       pop 2 values (False, False); check if both values are the same; push result (True)
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, True]

Step 582:
  program counter:   1008
  hvm code:          JumpCond False 1039
  explanation:       pop value (True), compare to False, and jump to 1039 if the same
  source code:       if election->citizens[citizen].voted == False:
                     ^^
  stack:             [{:}, 22050, { "result": None }]

Step 583:
  program counter:   1009
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=21 column=9
  end statement:     line=21 column=44
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e]

Step 584:
  program counter:   1010
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       election->candidates[candidate] += 1
                               ^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e, "candidates"]

Step 585:
  program counter:   1011
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["candidates"]]

Step 586:
  program counter:   1012
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       election->candidates[candidate] += 1
                                          ^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["candidates"], 1]

Step 587:
  program counter:   1013
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["candidates"]) and push the combined address (?e["candidates"][1])
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["candidates"][1]]

Step 588:
  program counter:   1014
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["candidates"][1], ?e["candidates"][1]]

Step 589:
  program counter:   1015
  hvm code:          Load
  explanation:       pop address of variable (?e["candidates"][1]) and push value (0)
  start expression:  line=21 column=9
  end expression:    line=21 column=44
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, { "result": None }, ?e["candidates"][1], 0]

Step 590:
  program counter:   1016
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       election->candidates[candidate] += 1
                                                        ^
  stack:             [{:}, 22050, { "result": None }, ?e["candidates"][1], 0, 1]

Step 591:
  program counter:   1017
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["candidates"][1], 1]

Step 592:
  program counter:   1018
  hvm code:          Store
  explanation:       pop value (1) and address (?e["candidates"][1]) and store
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 1 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, { "result": None }]

Step 593:
  program counter:   1019
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=22 column=9
  end statement:     line=22 column=48
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e]

Step 594:
  program counter:   1020
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted = True
                               ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e, "citizens"]

Step 595:
  program counter:   1021
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"]]

Step 596:
  program counter:   1022
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       election->citizens[citizen].voted = True
                                        ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"], 2]

Step 597:
  program counter:   1023
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2]]

Step 598:
  program counter:   1024
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       election->citizens[citizen].voted = True
                                                ^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2], "voted"]

Step 599:
  program counter:   1025
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted"])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2]["voted"]]

Step 600:
  program counter:   1026
  hvm code:          Push True
  explanation:       push constant True
  source code:       election->citizens[citizen].voted = True
                                                         ^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2]["voted"], True]

Step 601:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value (True) and address (?e["citizens"][2]["voted"]) and store
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 1 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": -1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, { "result": None }]

Step 602:
  program counter:   1028
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=23 column=9
  end statement:     line=23 column=57
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e]

Step 603:
  program counter:   1029
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted_for = candidate
                               ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e, "citizens"]

Step 604:
  program counter:   1030
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"]]

Step 605:
  program counter:   1031
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       election->citizens[citizen].voted_for = candidate
                                        ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"], 2]

Step 606:
  program counter:   1032
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["citizens"]) and push the combined address (?e["citizens"][2])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2]]

Step 607:
  program counter:   1033
  hvm code:          Push "voted_for"
  explanation:       push constant "voted_for"
  source code:       election->citizens[citizen].voted_for = candidate
                                                ^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2], "voted_for"]

Step 608:
  program counter:   1034
  hvm code:          Address
  explanation:       pop a key ("voted_for") and an address (?e["citizens"][2]) and push the combined address (?e["citizens"][2]["voted_for"])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2]["voted_for"]]

Step 609:
  program counter:   1035
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       election->citizens[citizen].voted_for = candidate
                                                             ^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, ?e["citizens"][2]["voted_for"], 1]

Step 610:
  program counter:   1036
  hvm code:          Store
  explanation:       pop value (1) and address (?e["citizens"][2]["voted_for"]) and store
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 1 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, True ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, { "result": None }]

Step 611:
  program counter:   1037
  hvm code:          Push True
  explanation:       push constant True
  start statement:   line=24 column=9
  end statement:     line=24 column=21
  source code:       result = True
                              ^^^^
  stack:             [{:}, 22050, { "result": None }, True]

Step 612:
  program counter:   1038
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = True
                     ^^^^^^^^
  method variables:  { candidate: 1, citizen: 2, election: ?e, result: True }
  stack:             [{:}, 22050, { "result": None }]

Step 613:
  program counter:   1039
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=18
  source code:       result = False
                              ^^^^^
  method variables:  { candidate: 1, citizen: 2, election: ?e }

Step 614:
  program counter:   1040
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=25 column=14
  end expression:    line=25 column=18
  stack:             [{:}, 22050, { "result": None }, False]

Step 615:
  program counter:   1041
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = False
                     ^^^^^^^^
  method variables:  { candidate: 1, citizen: 2, election: ?e, result: False }
  stack:             [{:}, 22050, { "result": None }]

Step 616:
  program counter:   1042
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714)]

Step 617:
  program counter:   1043
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e]

Step 618:
  program counter:   1044
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       release(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e, "locks_cit"]

Step 619:
  program counter:   1045
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e["locks_cit"]]

Step 620:
  program counter:   1046
  hvm code:          LoadVar citizen
  explanation:       push value (2) of variable "citizen"
  source code:       release(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e["locks_cit"], 2]

Step 621:
  program counter:   1047
  hvm code:          DelVar citizen
  explanation:       delete method variable citizen
  start expression:  line=28 column=35
  end expression:    line=28 column=41
  method variables:  { candidate: 1, election: ?e, result: False }

Step 622:
  program counter:   1048
  hvm code:          Address
  explanation:       pop a key (2) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][2])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e["locks_cit"][2]]

Step 623:
  program counter:   1049
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][2]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2) --> release(?e["locks_cit"][2])
  stack:             [{:}, 22050, { "result": None }, 16802, ?e["locks_cit"][2]]

Step 624:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_cit"][2]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][2], result: None }
  stack:             [{:}, 22050, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }]

Step 625:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2) --> release(?e["locks_cit"][2])

Step 626:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 627:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 628:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, ?e["locks_cit"][2]]

Step 629:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][2]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, True]

Step 630:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 22050, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }]

Step 631:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 632:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 633:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][2]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, ?e["locks_cit"][2]]

Step 634:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 635:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 22050, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, ?e["locks_cit"][2], False]

Step 636:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_cit"][2]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 1 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 22050, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }]

Step 637:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 638:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, election: ?e, result: False }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, { "result": None }, None]

Step 639:
  program counter:   1050
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }]

Step 640:
  program counter:   1051
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714)]

Step 641:
  program counter:   1052
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e]

Step 642:
  program counter:   1053
  hvm code:          DelVar election
  explanation:       delete method variable election
  start expression:  line=29 column=15
  end expression:    line=29 column=22
  method variables:  { candidate: 1, result: False }

Step 643:
  program counter:   1054
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e, "locks_can"]

Step 644:
  program counter:   1055
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e["locks_can"]]

Step 645:
  program counter:   1056
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       release(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e["locks_can"], 1]

Step 646:
  program counter:   1057
  hvm code:          DelVar candidate
  explanation:       delete method variable candidate
  start expression:  line=29 column=35
  end expression:    line=29 column=43
  method variables:  { result: False }

Step 647:
  program counter:   1058
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, PC(714), ?e["locks_can"][1]]

Step 648:
  program counter:   1059
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2) --> release(?e["locks_can"][1])
  stack:             [{:}, 22050, { "result": None }, 16962, ?e["locks_can"][1]]

Step 649:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, 22050, { "result": None }, 16962, { "result": False }]

Step 650:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2) --> release(?e["locks_can"][1])

Step 651:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 652:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 653:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 16962, { "result": False }, ?e["locks_can"][1]]

Step 654:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 16962, { "result": False }, True]

Step 655:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 22050, { "result": None }, 16962, { "result": False }]

Step 656:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 657:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 658:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 22050, { "result": None }, 16962, { "result": False }, ?e["locks_can"][1]]

Step 659:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 660:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 22050, { "result": None }, 16962, { "result": False }, ?e["locks_can"][1], False]

Step 661:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][1]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 1 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 0 }
  stack:             [{:}, 22050, { "result": None }, 16962, { "result": False }]

Step 662:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 663:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: False }
  call trace:        test_withdraw(?e, 0, 1, 2) --> vote(?e, 1, 2)
  stack:             [{:}, 22050, { "result": None }, None]

Step 664:
  program counter:   1060
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22050, { "result": None }]

Step 665:
  program counter:   1061
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        test_withdraw(?e, 0, 1, 2)
  stack:             [{:}, False]

Step 666:
  program counter:   1378
  hvm code:          Pop
  explanation:       pop and discard value (False)
  file:              electiontest.hny
  start statement:   line=25 column=5
  end statement:     line=25 column=51
  source code:       election.vote(e, second_candidate, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 667:
  program counter:   1379
  hvm code:          Push PC(1317)
  explanation:       push program counter constant 1317 ("complete")
  start statement:   line=26 column=5
  end statement:     line=26 column=14
  source code:       complete()
                     ^^^^^^^^
  stack:             [{:}, PC(1317)]

Step 668:
  program counter:   1380
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       complete()
                             ^^
  stack:             [{:}, PC(1317), []]

Step 669:
  program counter:   1381
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (1317: "complete") and call the method
  source code:       complete()
                     ^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> complete()
  stack:             [{:}, 22114, []]

Step 670:
  program counter:   1317
  hvm code:          Frame complete()
  explanation:       method "complete" with argument () set to []
  start statement:   line=14 column=1
  end statement:     line=14 column=15
  source code:       def complete():
                     ^^^^^^^^^^^^^^^
  stack:             [{:}, 22114, { "result": None }]

Step 671:
  program counter:   1318
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=15 column=5
  end statement:     line=15 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2) --> complete()

Step 672:
  program counter:   1319
  hvm code:          Load threads_executed
  explanation:       push value (0) of variable threads_executed
  start statement:   line=16 column=9
  end statement:     line=16 column=29
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22114, { "result": None }, 0]

Step 673:
  program counter:   1320
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       threads_executed += 1
                                         ^
  stack:             [{:}, 22114, { "result": None }, 0, 1]

Step 674:
  program counter:   1321
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22114, { "result": None }, 1]

Step 675:
  program counter:   1322
  hvm code:          Store threads_executed
  explanation:       pop value (1) and store into variable threads_executed
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 1 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 1 }
  stack:             [{:}, 22114, { "result": None }]

Step 676:
  program counter:   1323
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=15 column=5
  end statement:     line=15 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 677:
  program counter:   1324
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=14 column=1
  end statement:     line=14 column=15
  source code:       def complete():
                     ^^^^^^^^^^^^^^^
  call trace:        test_withdraw(?e, 0, 1, 2)
  stack:             [{:}, None]

Step 678:
  program counter:   1382
  hvm code:          Pop
  explanation:       pop and discard value (None)
  start statement:   line=26 column=5
  end statement:     line=26 column=14
  source code:       complete()
                     ^^^^^^^^^^
  stack:             [{:}]

Step 679:
  program counter:   1383
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=22 column=1
  end statement:     line=22 column=69
  source code:       def test_withdraw(e, first_candidate, second_candidate, citizen_idx):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  new mode:          terminated
  stack:             []

================================================
Running thread T2: test_vote(?e, 1, 1)
mode:  runnable
stack: ['[ ?e, 1, 1 ]']
other threads:
  T0: pc=1501 terminated atomic __init__()
  T1: pc=1326 runnable test_vote(?e, 0, 0)
  T3: pc=1326 runnable test_vote(?e, 1, 1)
  T4: pc=1383 terminated test_withdraw(?e, 0, 1, 2)
  T5: pc=1385 runnable end_test()
shared variables:
  EXPECTED_VOTES: [ 3, 0 ]
  NUM_CANDIDATES: 2
  NUM_CITIZENS: 3
  WINNER: 0
  e: { "candidates": [ 0, 1 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }
  number_of_spawned_threads: 4
  threads_executed: 1
state id: 7787
================================================

Step 680:
  program counter:   1326
  hvm code:          Frame test_vote(e, candidate_idx, citizen_idx)
  explanation:       method "test_vote" with argument (e, candidate_idx, citizen_idx) set to [?e, 1, 1]
  start statement:   line=18 column=1
  end statement:     line=18 column=45
  source code:       def test_vote(e, candidate_idx, citizen_idx):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate_idx: 1, citizen_idx: 1, e: ?e, result: None }
  call trace:        test_vote(?e, 1, 1)
  stack:             [{:}]

Step 681:
  program counter:   1327
  hvm code:          Push PC(980)
  explanation:       push program counter constant 980 ("vote")
  start statement:   line=19 column=5
  end statement:     line=19 column=48
  source code:       election.vote(e, candidate_idx, citizen_idx)
                     ^^^^^^^^^^^^^
  stack:             [{:}, PC(980)]

Step 682:
  program counter:   1328
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), []]

Step 683:
  program counter:   1329
  hvm code:          LoadVar e
  explanation:       push value (?e) of variable "e"
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^
  stack:             [{:}, PC(980), [], ?e]

Step 684:
  program counter:   1330
  hvm code:          DelVar e
  explanation:       delete method variable e
  start expression:  line=19 column=19
  end expression:    line=19 column=19
  method variables:  { candidate_idx: 1, citizen_idx: 1, result: None }

Step 685:
  program counter:   1331
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ]]

Step 686:
  program counter:   1332
  hvm code:          LoadVar candidate_idx
  explanation:       push value (1) of variable "candidate_idx"
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                      ^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ], 1]

Step 687:
  program counter:   1333
  hvm code:          DelVar candidate_idx
  explanation:       delete method variable candidate_idx
  start expression:  line=19 column=22
  end expression:    line=19 column=34
  method variables:  { citizen_idx: 1, result: None }

Step 688:
  program counter:   1334
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e]); insert first value into the second; push result ([?e, 1])
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 1 ]]

Step 689:
  program counter:   1335
  hvm code:          LoadVar citizen_idx
  explanation:       push value (1) of variable "citizen_idx"
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                                     ^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 1 ], 1]

Step 690:
  program counter:   1336
  hvm code:          DelVar citizen_idx
  explanation:       delete method variable citizen_idx
  start expression:  line=19 column=37
  end expression:    line=19 column=47
  method variables:  { result: None }

Step 691:
  program counter:   1337
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e, 1]); insert first value into the second; push result ([?e, 1, 1])
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 1, 1 ]]

Step 692:
  program counter:   1338
  hvm code:          Apply
  explanation:       pop an argument ([?e, 1, 1]) and a program counter value (980: "vote") and call the method
  source code:       election.vote(e, candidate_idx, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, [ ?e, 1, 1 ]]

Step 693:
  program counter:   980
  hvm code:          Frame vote(election, candidate, citizen)
  explanation:       method "vote" with argument (election, candidate, citizen) set to [?e, 1, 1]
  file:              electionimpl.hny
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e, result: None }
  stack:             [{:}, 21426, { "result": None }]

Step 694:
  program counter:   981
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e }

Step 695:
  program counter:   982
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start expression:  line=16 column=5
  end expression:    line=16 column=11
  stack:             [{:}, 21426, { "result": None }, PC(695)]

Step 696:
  program counter:   983
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e]

Step 697:
  program counter:   984
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e, "locks_can"]

Step 698:
  program counter:   985
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_can"]]

Step 699:
  program counter:   986
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       acquire(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_can"], 1]

Step 700:
  program counter:   987
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_can"][1]]

Step 701:
  program counter:   988
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> acquire(?e["locks_can"][1])
  stack:             [{:}, 21426, { "result": None }, 15826, ?e["locks_can"][1]]

Step 702:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 703:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> acquire(?e["locks_can"][1])

Step 704:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 705:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_can"][1]]

Step 706:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, False]

Step 707:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, True]

Step 708:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 709:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 710:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 711:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_can"][1]]

Step 712:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 713:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_can"][1], True]

Step 714:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][1]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 1 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 1 }
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 715:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 716:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, None]

Step 717:
  program counter:   989
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 718:
  program counter:   990
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695)]

Step 719:
  program counter:   991
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e]

Step 720:
  program counter:   992
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       acquire(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e, "locks_cit"]

Step 721:
  program counter:   993
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_cit"]]

Step 722:
  program counter:   994
  hvm code:          LoadVar citizen
  explanation:       push value (1) of variable "citizen"
  source code:       acquire(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_cit"], 1]

Step 723:
  program counter:   995
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][1])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_cit"][1]]

Step 724:
  program counter:   996
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][1]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> acquire(?e["locks_cit"][1])
  stack:             [{:}, 21426, { "result": None }, 15954, ?e["locks_cit"][1]]

Step 725:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_cit"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][1], result: None }
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 726:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> acquire(?e["locks_cit"][1])

Step 727:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 728:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][1]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_cit"][1]]

Step 729:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][1]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, False]

Step 730:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, True]

Step 731:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 732:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 733:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 734:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][1]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_cit"][1]]

Step 735:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 736:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_cit"][1], True]

Step 737:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_cit"][1]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 1 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, True, False ] }, number_of_spawned_threads: 4, threads_executed: 1 }
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 738:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 739:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, None]

Step 740:
  program counter:   997
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 741:
  program counter:   998
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=20 column=5
  end statement:     line=20 column=50
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e]

Step 742:
  program counter:   999
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       if election->citizens[citizen].voted == False:
                                  ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e, "citizens"]

Step 743:
  program counter:   1000
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"]]

Step 744:
  program counter:   1001
  hvm code:          LoadVar citizen
  explanation:       push value (1) of variable "citizen"
  source code:       if election->citizens[citizen].voted == False:
                                           ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"], 1]

Step 745:
  program counter:   1002
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["citizens"]) and push the combined address (?e["citizens"][1])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]]

Step 746:
  program counter:   1003
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       if election->citizens[citizen].voted == False:
                                                   ^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1], "voted"]

Step 747:
  program counter:   1004
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][1]) and push the combined address (?e["citizens"][1]["voted"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]["voted"]]

Step 748:
  program counter:   1005
  hvm code:          Load
  explanation:       pop address of variable (?e["citizens"][1]["voted"]) and push value (False)
  start expression:  line=20 column=8
  end expression:    line=20 column=40
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, False]

Step 749:
  program counter:   1006
  hvm code:          Push False
  explanation:       push constant False
  source code:       if election->citizens[citizen].voted == False:
                                                             ^^^^^
  stack:             [{:}, 21426, { "result": None }, False, False]

Step 750:
  program counter:   1007
  hvm code:          2-ary ==
  explanation:       pop 2 values (False, False); check if both values are the same; push result (True)
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, True]

Step 751:
  program counter:   1008
  hvm code:          JumpCond False 1039
  explanation:       pop value (True), compare to False, and jump to 1039 if the same
  source code:       if election->citizens[citizen].voted == False:
                     ^^
  stack:             [{:}, 21426, { "result": None }]

Step 752:
  program counter:   1009
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=21 column=9
  end statement:     line=21 column=44
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e]

Step 753:
  program counter:   1010
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       election->candidates[candidate] += 1
                               ^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e, "candidates"]

Step 754:
  program counter:   1011
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"]]

Step 755:
  program counter:   1012
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       election->candidates[candidate] += 1
                                          ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"], 1]

Step 756:
  program counter:   1013
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["candidates"]) and push the combined address (?e["candidates"][1])
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][1]]

Step 757:
  program counter:   1014
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][1], ?e["candidates"][1]]

Step 758:
  program counter:   1015
  hvm code:          Load
  explanation:       pop address of variable (?e["candidates"][1]) and push value (1)
  start expression:  line=21 column=9
  end expression:    line=21 column=44
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][1], 1]

Step 759:
  program counter:   1016
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       election->candidates[candidate] += 1
                                                        ^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][1], 1, 1]

Step 760:
  program counter:   1017
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 1); add the integers; push result (2)
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][1], 2]

Step 761:
  program counter:   1018
  hvm code:          Store
  explanation:       pop value (2) and address (?e["candidates"][1]) and store
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, True, False ] }, number_of_spawned_threads: 4, threads_executed: 1 }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }]

Step 762:
  program counter:   1019
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=22 column=9
  end statement:     line=22 column=48
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e]

Step 763:
  program counter:   1020
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted = True
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e, "citizens"]

Step 764:
  program counter:   1021
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"]]

Step 765:
  program counter:   1022
  hvm code:          LoadVar citizen
  explanation:       push value (1) of variable "citizen"
  source code:       election->citizens[citizen].voted = True
                                        ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"], 1]

Step 766:
  program counter:   1023
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["citizens"]) and push the combined address (?e["citizens"][1])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]]

Step 767:
  program counter:   1024
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       election->citizens[citizen].voted = True
                                                ^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1], "voted"]

Step 768:
  program counter:   1025
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][1]) and push the combined address (?e["citizens"][1]["voted"])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]["voted"]]

Step 769:
  program counter:   1026
  hvm code:          Push True
  explanation:       push constant True
  source code:       election->citizens[citizen].voted = True
                                                         ^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]["voted"], True]

Step 770:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value (True) and address (?e["citizens"][1]["voted"]) and store
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": -1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, True, False ] }, number_of_spawned_threads: 4, threads_executed: 1 }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }]

Step 771:
  program counter:   1028
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=23 column=9
  end statement:     line=23 column=57
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e]

Step 772:
  program counter:   1029
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted_for = candidate
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e, "citizens"]

Step 773:
  program counter:   1030
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"]]

Step 774:
  program counter:   1031
  hvm code:          LoadVar citizen
  explanation:       push value (1) of variable "citizen"
  source code:       election->citizens[citizen].voted_for = candidate
                                        ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"], 1]

Step 775:
  program counter:   1032
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["citizens"]) and push the combined address (?e["citizens"][1])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]]

Step 776:
  program counter:   1033
  hvm code:          Push "voted_for"
  explanation:       push constant "voted_for"
  source code:       election->citizens[citizen].voted_for = candidate
                                                ^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1], "voted_for"]

Step 777:
  program counter:   1034
  hvm code:          Address
  explanation:       pop a key ("voted_for") and an address (?e["citizens"][1]) and push the combined address (?e["citizens"][1]["voted_for"])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]["voted_for"]]

Step 778:
  program counter:   1035
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       election->citizens[citizen].voted_for = candidate
                                                             ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]["voted_for"], 1]

Step 779:
  program counter:   1036
  hvm code:          Store
  explanation:       pop value (1) and address (?e["citizens"][1]["voted_for"]) and store
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, True, False ] }, number_of_spawned_threads: 4, threads_executed: 1 }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }]

Step 780:
  program counter:   1037
  hvm code:          Push True
  explanation:       push constant True
  start statement:   line=24 column=9
  end statement:     line=24 column=21
  source code:       result = True
                              ^^^^
  stack:             [{:}, 21426, { "result": None }, True]

Step 781:
  program counter:   1038
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = True
                     ^^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e, result: True }
  stack:             [{:}, 21426, { "result": None }]

Step 782:
  program counter:   1039
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=18
  source code:       result = False
                              ^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e }

Step 783:
  program counter:   1040
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=25 column=14
  end expression:    line=25 column=18
  stack:             [{:}, 21426, { "result": None }, False]

Step 784:
  program counter:   1041
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = False
                     ^^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e, result: False }
  stack:             [{:}, 21426, { "result": None }]

Step 785:
  program counter:   1042
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714)]

Step 786:
  program counter:   1043
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e]

Step 787:
  program counter:   1044
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       release(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e, "locks_cit"]

Step 788:
  program counter:   1045
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_cit"]]

Step 789:
  program counter:   1046
  hvm code:          LoadVar citizen
  explanation:       push value (1) of variable "citizen"
  source code:       release(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_cit"], 1]

Step 790:
  program counter:   1047
  hvm code:          DelVar citizen
  explanation:       delete method variable citizen
  start expression:  line=28 column=35
  end expression:    line=28 column=41
  method variables:  { candidate: 1, election: ?e, result: False }

Step 791:
  program counter:   1048
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][1])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_cit"][1]]

Step 792:
  program counter:   1049
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][1]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> release(?e["locks_cit"][1])
  stack:             [{:}, 21426, { "result": None }, 16802, ?e["locks_cit"][1]]

Step 793:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_cit"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][1], result: None }
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }]

Step 794:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> release(?e["locks_cit"][1])

Step 795:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 796:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 797:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][1]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, ?e["locks_cit"][1]]

Step 798:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][1]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, True]

Step 799:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }]

Step 800:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 801:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 802:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][1]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, ?e["locks_cit"][1]]

Step 803:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 804:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, ?e["locks_cit"][1], False]

Step 805:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_cit"][1]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 1 }
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }]

Step 806:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 807:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, election: ?e, result: False }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, None]

Step 808:
  program counter:   1050
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 809:
  program counter:   1051
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714)]

Step 810:
  program counter:   1052
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e]

Step 811:
  program counter:   1053
  hvm code:          DelVar election
  explanation:       delete method variable election
  start expression:  line=29 column=15
  end expression:    line=29 column=22
  method variables:  { candidate: 1, result: False }

Step 812:
  program counter:   1054
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e, "locks_can"]

Step 813:
  program counter:   1055
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_can"]]

Step 814:
  program counter:   1056
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       release(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_can"], 1]

Step 815:
  program counter:   1057
  hvm code:          DelVar candidate
  explanation:       delete method variable candidate
  start expression:  line=29 column=35
  end expression:    line=29 column=43
  method variables:  { result: False }

Step 816:
  program counter:   1058
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_can"][1]]

Step 817:
  program counter:   1059
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> release(?e["locks_can"][1])
  stack:             [{:}, 21426, { "result": None }, 16962, ?e["locks_can"][1]]

Step 818:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }]

Step 819:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> release(?e["locks_can"][1])

Step 820:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 821:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 822:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, ?e["locks_can"][1]]

Step 823:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, True]

Step 824:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }]

Step 825:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 826:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 827:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, ?e["locks_can"][1]]

Step 828:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 829:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, ?e["locks_can"][1], False]

Step 830:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][1]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 1 }
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }]

Step 831:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 832:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: False }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, None]

Step 833:
  program counter:   1060
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 834:
  program counter:   1061
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        test_vote(?e, 1, 1)
  stack:             [{:}, False]

Step 835:
  program counter:   1339
  hvm code:          Pop
  explanation:       pop and discard value (False)
  file:              electiontest.hny
  start statement:   line=19 column=5
  end statement:     line=19 column=48
  source code:       election.vote(e, candidate_idx, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 836:
  program counter:   1340
  hvm code:          Push PC(1317)
  explanation:       push program counter constant 1317 ("complete")
  start statement:   line=20 column=5
  end statement:     line=20 column=14
  source code:       complete()
                     ^^^^^^^^
  stack:             [{:}, PC(1317)]

Step 837:
  program counter:   1341
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       complete()
                             ^^
  stack:             [{:}, PC(1317), []]

Step 838:
  program counter:   1342
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (1317: "complete") and call the method
  source code:       complete()
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> complete()
  stack:             [{:}, 21490, []]

Step 839:
  program counter:   1317
  hvm code:          Frame complete()
  explanation:       method "complete" with argument () set to []
  start statement:   line=14 column=1
  end statement:     line=14 column=15
  source code:       def complete():
                     ^^^^^^^^^^^^^^^
  stack:             [{:}, 21490, { "result": None }]

Step 840:
  program counter:   1318
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=15 column=5
  end statement:     line=15 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> complete()

Step 841:
  program counter:   1319
  hvm code:          Load threads_executed
  explanation:       push value (1) of variable threads_executed
  start statement:   line=16 column=9
  end statement:     line=16 column=29
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21490, { "result": None }, 1]

Step 842:
  program counter:   1320
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       threads_executed += 1
                                         ^
  stack:             [{:}, 21490, { "result": None }, 1, 1]

Step 843:
  program counter:   1321
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 1); add the integers; push result (2)
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21490, { "result": None }, 2]

Step 844:
  program counter:   1322
  hvm code:          Store threads_executed
  explanation:       pop value (2) and store into variable threads_executed
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 2 }
  stack:             [{:}, 21490, { "result": None }]

Step 845:
  program counter:   1323
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=15 column=5
  end statement:     line=15 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 846:
  program counter:   1324
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=14 column=1
  end statement:     line=14 column=15
  source code:       def complete():
                     ^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1)
  stack:             [{:}, None]

Step 847:
  program counter:   1343
  hvm code:          Pop
  explanation:       pop and discard value (None)
  start statement:   line=20 column=5
  end statement:     line=20 column=14
  source code:       complete()
                     ^^^^^^^^^^
  stack:             [{:}]

Step 848:
  program counter:   1344
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=18 column=1
  end statement:     line=18 column=45
  source code:       def test_vote(e, candidate_idx, citizen_idx):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  new mode:          terminated
  stack:             []

================================================
Running thread T3: test_vote(?e, 1, 1)
mode:  runnable
stack: ['[ ?e, 1, 1 ]']
other threads:
  T0: pc=1501 terminated atomic __init__()
  T1: pc=1326 runnable test_vote(?e, 0, 0)
  T2: pc=1344 terminated test_vote(?e, 1, 1)
  T4: pc=1383 terminated test_withdraw(?e, 0, 1, 2)
  T5: pc=1385 runnable end_test()
shared variables:
  EXPECTED_VOTES: [ 3, 0 ]
  NUM_CANDIDATES: 2
  NUM_CITIZENS: 3
  WINNER: 0
  e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }
  number_of_spawned_threads: 4
  threads_executed: 2
state id: 11064
================================================

Step 849:
  program counter:   1326
  hvm code:          Frame test_vote(e, candidate_idx, citizen_idx)
  explanation:       method "test_vote" with argument (e, candidate_idx, citizen_idx) set to [?e, 1, 1]
  start expression:  line=18 column=1
  end expression:    line=18 column=45
  method variables:  { candidate_idx: 1, citizen_idx: 1, e: ?e, result: None }
  call trace:        test_vote(?e, 1, 1)
  stack:             [{:}]

Step 850:
  program counter:   1327
  hvm code:          Push PC(980)
  explanation:       push program counter constant 980 ("vote")
  start statement:   line=19 column=5
  end statement:     line=19 column=48
  source code:       election.vote(e, candidate_idx, citizen_idx)
                     ^^^^^^^^^^^^^
  stack:             [{:}, PC(980)]

Step 851:
  program counter:   1328
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), []]

Step 852:
  program counter:   1329
  hvm code:          LoadVar e
  explanation:       push value (?e) of variable "e"
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^
  stack:             [{:}, PC(980), [], ?e]

Step 853:
  program counter:   1330
  hvm code:          DelVar e
  explanation:       delete method variable e
  start expression:  line=19 column=19
  end expression:    line=19 column=19
  method variables:  { candidate_idx: 1, citizen_idx: 1, result: None }

Step 854:
  program counter:   1331
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ]]

Step 855:
  program counter:   1332
  hvm code:          LoadVar candidate_idx
  explanation:       push value (1) of variable "candidate_idx"
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                      ^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ], 1]

Step 856:
  program counter:   1333
  hvm code:          DelVar candidate_idx
  explanation:       delete method variable candidate_idx
  start expression:  line=19 column=22
  end expression:    line=19 column=34
  method variables:  { citizen_idx: 1, result: None }

Step 857:
  program counter:   1334
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e]); insert first value into the second; push result ([?e, 1])
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 1 ]]

Step 858:
  program counter:   1335
  hvm code:          LoadVar citizen_idx
  explanation:       push value (1) of variable "citizen_idx"
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                                     ^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 1 ], 1]

Step 859:
  program counter:   1336
  hvm code:          DelVar citizen_idx
  explanation:       delete method variable citizen_idx
  start expression:  line=19 column=37
  end expression:    line=19 column=47
  method variables:  { result: None }

Step 860:
  program counter:   1337
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e, 1]); insert first value into the second; push result ([?e, 1, 1])
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 1, 1 ]]

Step 861:
  program counter:   1338
  hvm code:          Apply
  explanation:       pop an argument ([?e, 1, 1]) and a program counter value (980: "vote") and call the method
  source code:       election.vote(e, candidate_idx, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, [ ?e, 1, 1 ]]

Step 862:
  program counter:   980
  hvm code:          Frame vote(election, candidate, citizen)
  explanation:       method "vote" with argument (election, candidate, citizen) set to [?e, 1, 1]
  file:              electionimpl.hny
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e, result: None }
  stack:             [{:}, 21426, { "result": None }]

Step 863:
  program counter:   981
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e }

Step 864:
  program counter:   982
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start expression:  line=16 column=5
  end expression:    line=16 column=11
  stack:             [{:}, 21426, { "result": None }, PC(695)]

Step 865:
  program counter:   983
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e]

Step 866:
  program counter:   984
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e, "locks_can"]

Step 867:
  program counter:   985
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_can"]]

Step 868:
  program counter:   986
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       acquire(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_can"], 1]

Step 869:
  program counter:   987
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_can"][1]]

Step 870:
  program counter:   988
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> acquire(?e["locks_can"][1])
  stack:             [{:}, 21426, { "result": None }, 15826, ?e["locks_can"][1]]

Step 871:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 872:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> acquire(?e["locks_can"][1])

Step 873:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 874:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_can"][1]]

Step 875:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, False]

Step 876:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, True]

Step 877:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 878:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 879:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 880:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_can"][1]]

Step 881:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 882:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_can"][1], True]

Step 883:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][1]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 2 }
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 884:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 885:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, None]

Step 886:
  program counter:   989
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 887:
  program counter:   990
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695)]

Step 888:
  program counter:   991
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e]

Step 889:
  program counter:   992
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       acquire(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e, "locks_cit"]

Step 890:
  program counter:   993
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_cit"]]

Step 891:
  program counter:   994
  hvm code:          LoadVar citizen
  explanation:       push value (1) of variable "citizen"
  source code:       acquire(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_cit"], 1]

Step 892:
  program counter:   995
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][1])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_cit"][1]]

Step 893:
  program counter:   996
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][1]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> acquire(?e["locks_cit"][1])
  stack:             [{:}, 21426, { "result": None }, 15954, ?e["locks_cit"][1]]

Step 894:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_cit"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][1], result: None }
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 895:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> acquire(?e["locks_cit"][1])

Step 896:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 897:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][1]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_cit"][1]]

Step 898:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][1]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, False]

Step 899:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, True]

Step 900:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 901:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 902:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 903:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][1]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_cit"][1]]

Step 904:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 905:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }, ?e["locks_cit"][1], True]

Step 906:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_cit"][1]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, True, False ] }, number_of_spawned_threads: 4, threads_executed: 2 }
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 1, "citizen": 1, "election": ?e }]

Step 907:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 908:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, None]

Step 909:
  program counter:   997
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 910:
  program counter:   998
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=20 column=5
  end statement:     line=20 column=50
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e]

Step 911:
  program counter:   999
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       if election->citizens[citizen].voted == False:
                                  ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e, "citizens"]

Step 912:
  program counter:   1000
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"]]

Step 913:
  program counter:   1001
  hvm code:          LoadVar citizen
  explanation:       push value (1) of variable "citizen"
  source code:       if election->citizens[citizen].voted == False:
                                           ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"], 1]

Step 914:
  program counter:   1002
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["citizens"]) and push the combined address (?e["citizens"][1])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]]

Step 915:
  program counter:   1003
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       if election->citizens[citizen].voted == False:
                                                   ^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1], "voted"]

Step 916:
  program counter:   1004
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][1]) and push the combined address (?e["citizens"][1]["voted"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][1]["voted"]]

Step 917:
  program counter:   1005
  hvm code:          Load
  explanation:       pop address of variable (?e["citizens"][1]["voted"]) and push value (True)
  start expression:  line=20 column=8
  end expression:    line=20 column=40
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, True]

Step 918:
  program counter:   1006
  hvm code:          Push False
  explanation:       push constant False
  source code:       if election->citizens[citizen].voted == False:
                                                             ^^^^^
  stack:             [{:}, 21426, { "result": None }, True, False]

Step 919:
  program counter:   1007
  hvm code:          2-ary ==
  explanation:       pop 2 values (False, True); check if both values are the same; push result (False)
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, False]

Step 920:
  program counter:   1008
  hvm code:          JumpCond False 1039
  explanation:       pop value (False), compare to False, and jump to 1039 if the same
  source code:       if election->citizens[citizen].voted == False:
                     ^^
  stack:             [{:}, 21426, { "result": None }]

Step 921:
  program counter:   1039
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=18
  source code:       result = False
                              ^^^^^

Step 922:
  program counter:   1040
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=25 column=14
  end expression:    line=25 column=18
  stack:             [{:}, 21426, { "result": None }, False]

Step 923:
  program counter:   1041
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = False
                     ^^^^^^^^
  method variables:  { candidate: 1, citizen: 1, election: ?e, result: False }
  stack:             [{:}, 21426, { "result": None }]

Step 924:
  program counter:   1042
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714)]

Step 925:
  program counter:   1043
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e]

Step 926:
  program counter:   1044
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       release(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e, "locks_cit"]

Step 927:
  program counter:   1045
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_cit"]]

Step 928:
  program counter:   1046
  hvm code:          LoadVar citizen
  explanation:       push value (1) of variable "citizen"
  source code:       release(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_cit"], 1]

Step 929:
  program counter:   1047
  hvm code:          DelVar citizen
  explanation:       delete method variable citizen
  start expression:  line=28 column=35
  end expression:    line=28 column=41
  method variables:  { candidate: 1, election: ?e, result: False }

Step 930:
  program counter:   1048
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][1])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_cit"][1]]

Step 931:
  program counter:   1049
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][1]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> release(?e["locks_cit"][1])
  stack:             [{:}, 21426, { "result": None }, 16802, ?e["locks_cit"][1]]

Step 932:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_cit"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][1], result: None }
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }]

Step 933:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> release(?e["locks_cit"][1])

Step 934:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 935:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 936:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][1]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, ?e["locks_cit"][1]]

Step 937:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][1]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, True]

Step 938:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }]

Step 939:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 940:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 941:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][1]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, ?e["locks_cit"][1]]

Step 942:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 943:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }, ?e["locks_cit"][1], False]

Step 944:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_cit"][1]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 2 }
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 1, "election": ?e, "result": False }]

Step 945:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 946:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, election: ?e, result: False }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, None]

Step 947:
  program counter:   1050
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 948:
  program counter:   1051
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714)]

Step 949:
  program counter:   1052
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e]

Step 950:
  program counter:   1053
  hvm code:          DelVar election
  explanation:       delete method variable election
  start expression:  line=29 column=15
  end expression:    line=29 column=22
  method variables:  { candidate: 1, result: False }

Step 951:
  program counter:   1054
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e, "locks_can"]

Step 952:
  program counter:   1055
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_can"]]

Step 953:
  program counter:   1056
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       release(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_can"], 1]

Step 954:
  program counter:   1057
  hvm code:          DelVar candidate
  explanation:       delete method variable candidate
  start expression:  line=29 column=35
  end expression:    line=29 column=43
  method variables:  { result: False }

Step 955:
  program counter:   1058
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_can"][1]]

Step 956:
  program counter:   1059
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> release(?e["locks_can"][1])
  stack:             [{:}, 21426, { "result": None }, 16962, ?e["locks_can"][1]]

Step 957:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }]

Step 958:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1) --> release(?e["locks_can"][1])

Step 959:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 960:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 961:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, ?e["locks_can"][1]]

Step 962:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, True]

Step 963:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }]

Step 964:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 965:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 966:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, ?e["locks_can"][1]]

Step 967:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 968:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, ?e["locks_can"][1], False]

Step 969:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][1]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 2 }
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }]

Step 970:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 971:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: False }
  call trace:        test_vote(?e, 1, 1) --> vote(?e, 1, 1)
  stack:             [{:}, 21426, { "result": None }, None]

Step 972:
  program counter:   1060
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 973:
  program counter:   1061
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        test_vote(?e, 1, 1)
  stack:             [{:}, False]

Step 974:
  program counter:   1339
  hvm code:          Pop
  explanation:       pop and discard value (False)
  file:              electiontest.hny
  start statement:   line=19 column=5
  end statement:     line=19 column=48
  source code:       election.vote(e, candidate_idx, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 975:
  program counter:   1340
  hvm code:          Push PC(1317)
  explanation:       push program counter constant 1317 ("complete")
  start statement:   line=20 column=5
  end statement:     line=20 column=14
  source code:       complete()
                     ^^^^^^^^
  stack:             [{:}, PC(1317)]

Step 976:
  program counter:   1341
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       complete()
                             ^^
  stack:             [{:}, PC(1317), []]

Step 977:
  program counter:   1342
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (1317: "complete") and call the method
  source code:       complete()
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> complete()
  stack:             [{:}, 21490, []]

Step 978:
  program counter:   1317
  hvm code:          Frame complete()
  explanation:       method "complete" with argument () set to []
  start statement:   line=14 column=1
  end statement:     line=14 column=15
  source code:       def complete():
                     ^^^^^^^^^^^^^^^
  stack:             [{:}, 21490, { "result": None }]

Step 979:
  program counter:   1318
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=15 column=5
  end statement:     line=15 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1) --> complete()

Step 980:
  program counter:   1319
  hvm code:          Load threads_executed
  explanation:       push value (2) of variable threads_executed
  start statement:   line=16 column=9
  end statement:     line=16 column=29
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21490, { "result": None }, 2]

Step 981:
  program counter:   1320
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       threads_executed += 1
                                         ^
  stack:             [{:}, 21490, { "result": None }, 2, 1]

Step 982:
  program counter:   1321
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 2); add the integers; push result (3)
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21490, { "result": None }, 3]

Step 983:
  program counter:   1322
  hvm code:          Store threads_executed
  explanation:       pop value (3) and store into variable threads_executed
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 3 }
  stack:             [{:}, 21490, { "result": None }]

Step 984:
  program counter:   1323
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=15 column=5
  end statement:     line=15 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 985:
  program counter:   1324
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=14 column=1
  end statement:     line=14 column=15
  source code:       def complete():
                     ^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 1, 1)
  stack:             [{:}, None]

Step 986:
  program counter:   1343
  hvm code:          Pop
  explanation:       pop and discard value (None)
  start statement:   line=20 column=5
  end statement:     line=20 column=14
  source code:       complete()
                     ^^^^^^^^^^
  stack:             [{:}]

Step 987:
  program counter:   1344
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=18 column=1
  end statement:     line=18 column=45
  source code:       def test_vote(e, candidate_idx, citizen_idx):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  new mode:          terminated
  stack:             []

================================================
Running thread T1: test_vote(?e, 0, 0)
mode:  runnable
stack: ['[ ?e, 0, 0 ]']
other threads:
  T0: pc=1501 terminated atomic __init__()
  T2: pc=1344 terminated test_vote(?e, 1, 1)
  T3: pc=1344 terminated test_vote(?e, 1, 1)
  T4: pc=1383 terminated test_withdraw(?e, 0, 1, 2)
  T5: pc=1385 runnable end_test()
shared variables:
  EXPECTED_VOTES: [ 3, 0 ]
  NUM_CANDIDATES: 2
  NUM_CITIZENS: 3
  WINNER: 0
  e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }
  number_of_spawned_threads: 4
  threads_executed: 3
state id: 12546
================================================

Step 988:
  program counter:   1326
  hvm code:          Frame test_vote(e, candidate_idx, citizen_idx)
  explanation:       method "test_vote" with argument (e, candidate_idx, citizen_idx) set to [?e, 0, 0]
  start expression:  line=18 column=1
  end expression:    line=18 column=45
  method variables:  { candidate_idx: 0, citizen_idx: 0, e: ?e, result: None }
  call trace:        test_vote(?e, 0, 0)
  stack:             [{:}]

Step 989:
  program counter:   1327
  hvm code:          Push PC(980)
  explanation:       push program counter constant 980 ("vote")
  start statement:   line=19 column=5
  end statement:     line=19 column=48
  source code:       election.vote(e, candidate_idx, citizen_idx)
                     ^^^^^^^^^^^^^
  stack:             [{:}, PC(980)]

Step 990:
  program counter:   1328
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), []]

Step 991:
  program counter:   1329
  hvm code:          LoadVar e
  explanation:       push value (?e) of variable "e"
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^
  stack:             [{:}, PC(980), [], ?e]

Step 992:
  program counter:   1330
  hvm code:          DelVar e
  explanation:       delete method variable e
  start expression:  line=19 column=19
  end expression:    line=19 column=19
  method variables:  { candidate_idx: 0, citizen_idx: 0, result: None }

Step 993:
  program counter:   1331
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ]]

Step 994:
  program counter:   1332
  hvm code:          LoadVar candidate_idx
  explanation:       push value (0) of variable "candidate_idx"
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                      ^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e ], 0]

Step 995:
  program counter:   1333
  hvm code:          DelVar candidate_idx
  explanation:       delete method variable candidate_idx
  start expression:  line=19 column=22
  end expression:    line=19 column=34
  method variables:  { citizen_idx: 0, result: None }

Step 996:
  program counter:   1334
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [?e]); insert first value into the second; push result ([?e, 0])
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 0 ]]

Step 997:
  program counter:   1335
  hvm code:          LoadVar citizen_idx
  explanation:       push value (0) of variable "citizen_idx"
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                                     ^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 0 ], 0]

Step 998:
  program counter:   1336
  hvm code:          DelVar citizen_idx
  explanation:       delete method variable citizen_idx
  start expression:  line=19 column=37
  end expression:    line=19 column=47
  method variables:  { result: None }

Step 999:
  program counter:   1337
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [?e, 0]); insert first value into the second; push result ([?e, 0, 0])
  source code:       election.vote(e, candidate_idx, citizen_idx)
                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(980), [ ?e, 0, 0 ]]

Step 1000:
  program counter:   1338
  hvm code:          Apply
  explanation:       pop an argument ([?e, 0, 0]) and a program counter value (980: "vote") and call the method
  source code:       election.vote(e, candidate_idx, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, [ ?e, 0, 0 ]]

Step 1001:
  program counter:   980
  hvm code:          Frame vote(election, candidate, citizen)
  explanation:       method "vote" with argument (election, candidate, citizen) set to [?e, 0, 0]
  file:              electionimpl.hny
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 0, election: ?e, result: None }
  stack:             [{:}, 21426, { "result": None }]

Step 1002:
  program counter:   981
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^
  method variables:  { candidate: 0, citizen: 0, election: ?e }

Step 1003:
  program counter:   982
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start expression:  line=16 column=5
  end expression:    line=16 column=11
  stack:             [{:}, 21426, { "result": None }, PC(695)]

Step 1004:
  program counter:   983
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e]

Step 1005:
  program counter:   984
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e, "locks_can"]

Step 1006:
  program counter:   985
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_can"]]

Step 1007:
  program counter:   986
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       acquire(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_can"], 0]

Step 1008:
  program counter:   987
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_can"][0]]

Step 1009:
  program counter:   988
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0) --> acquire(?e["locks_can"][0])
  stack:             [{:}, 21426, { "result": None }, 15826, ?e["locks_can"][0]]

Step 1010:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 0, "citizen": 0, "election": ?e }]

Step 1011:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0) --> acquire(?e["locks_can"][0])

Step 1012:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 1013:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 0, "citizen": 0, "election": ?e }, ?e["locks_can"][0]]

Step 1014:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 0, "citizen": 0, "election": ?e }, False]

Step 1015:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 0, "citizen": 0, "election": ?e }, True]

Step 1016:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 0, "citizen": 0, "election": ?e }]

Step 1017:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 1018:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1019:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 0, "citizen": 0, "election": ?e }, ?e["locks_can"][0]]

Step 1020:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 1021:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 0, "citizen": 0, "election": ?e }, ?e["locks_can"][0], True]

Step 1022:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][0]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 3 }
  stack:             [{:}, 21426, { "result": None }, 15826, { "candidate": 0, "citizen": 0, "election": ?e }]

Step 1023:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1024:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 0, election: ?e }
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, { "result": None }, None]

Step 1025:
  program counter:   989
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=16 column=5
  end statement:     line=16 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 1026:
  program counter:   990
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695)]

Step 1027:
  program counter:   991
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e]

Step 1028:
  program counter:   992
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       acquire(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e, "locks_cit"]

Step 1029:
  program counter:   993
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_cit"]]

Step 1030:
  program counter:   994
  hvm code:          LoadVar citizen
  explanation:       push value (0) of variable "citizen"
  source code:       acquire(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_cit"], 0]

Step 1031:
  program counter:   995
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][0])
  source code:       acquire(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(695), ?e["locks_cit"][0]]

Step 1032:
  program counter:   996
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][0]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0) --> acquire(?e["locks_cit"][0])
  stack:             [{:}, 21426, { "result": None }, 15954, ?e["locks_cit"][0]]

Step 1033:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_cit"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][0], result: None }
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 0, "citizen": 0, "election": ?e }]

Step 1034:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0) --> acquire(?e["locks_cit"][0])

Step 1035:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 1036:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][0]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 0, "citizen": 0, "election": ?e }, ?e["locks_cit"][0]]

Step 1037:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][0]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 0, "citizen": 0, "election": ?e }, False]

Step 1038:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 0, "citizen": 0, "election": ?e }, True]

Step 1039:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 0, "citizen": 0, "election": ?e }]

Step 1040:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 1041:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1042:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][0]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 0, "citizen": 0, "election": ?e }, ?e["locks_cit"][0]]

Step 1043:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 1044:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 0, "citizen": 0, "election": ?e }, ?e["locks_cit"][0], True]

Step 1045:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_cit"][0]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 0, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, False ], "locks_cit": [ True, False, False ] }, number_of_spawned_threads: 4, threads_executed: 3 }
  stack:             [{:}, 21426, { "result": None }, 15954, { "candidate": 0, "citizen": 0, "election": ?e }]

Step 1046:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1047:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, citizen: 0, election: ?e }
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, { "result": None }, None]

Step 1048:
  program counter:   997
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=17 column=5
  end statement:     line=17 column=44
  source code:       acquire(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 1049:
  program counter:   998
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=20 column=5
  end statement:     line=20 column=50
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e]

Step 1050:
  program counter:   999
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       if election->citizens[citizen].voted == False:
                                  ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e, "citizens"]

Step 1051:
  program counter:   1000
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"]]

Step 1052:
  program counter:   1001
  hvm code:          LoadVar citizen
  explanation:       push value (0) of variable "citizen"
  source code:       if election->citizens[citizen].voted == False:
                                           ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"], 0]

Step 1053:
  program counter:   1002
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["citizens"]) and push the combined address (?e["citizens"][0])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0]]

Step 1054:
  program counter:   1003
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       if election->citizens[citizen].voted == False:
                                                   ^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0], "voted"]

Step 1055:
  program counter:   1004
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][0]) and push the combined address (?e["citizens"][0]["voted"])
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0]["voted"]]

Step 1056:
  program counter:   1005
  hvm code:          Load
  explanation:       pop address of variable (?e["citizens"][0]["voted"]) and push value (False)
  start expression:  line=20 column=8
  end expression:    line=20 column=40
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, { "result": None }, False]

Step 1057:
  program counter:   1006
  hvm code:          Push False
  explanation:       push constant False
  source code:       if election->citizens[citizen].voted == False:
                                                             ^^^^^
  stack:             [{:}, 21426, { "result": None }, False, False]

Step 1058:
  program counter:   1007
  hvm code:          2-ary ==
  explanation:       pop 2 values (False, False); check if both values are the same; push result (True)
  source code:       if election->citizens[citizen].voted == False:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, True]

Step 1059:
  program counter:   1008
  hvm code:          JumpCond False 1039
  explanation:       pop value (True), compare to False, and jump to 1039 if the same
  source code:       if election->citizens[citizen].voted == False:
                     ^^
  stack:             [{:}, 21426, { "result": None }]

Step 1060:
  program counter:   1009
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=21 column=9
  end statement:     line=21 column=44
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e]

Step 1061:
  program counter:   1010
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       election->candidates[candidate] += 1
                               ^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e, "candidates"]

Step 1062:
  program counter:   1011
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"]]

Step 1063:
  program counter:   1012
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       election->candidates[candidate] += 1
                                          ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"], 0]

Step 1064:
  program counter:   1013
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["candidates"]) and push the combined address (?e["candidates"][0])
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][0]]

Step 1065:
  program counter:   1014
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][0], ?e["candidates"][0]]

Step 1066:
  program counter:   1015
  hvm code:          Load
  explanation:       pop address of variable (?e["candidates"][0]) and push value (0)
  start expression:  line=21 column=9
  end expression:    line=21 column=44
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][0], 0]

Step 1067:
  program counter:   1016
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       election->candidates[candidate] += 1
                                                        ^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][0], 0, 1]

Step 1068:
  program counter:   1017
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 0); add the integers; push result (1)
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["candidates"][0], 1]

Step 1069:
  program counter:   1018
  hvm code:          Store
  explanation:       pop value (1) and address (?e["candidates"][0]) and store
  source code:       election->candidates[candidate] += 1
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 2 ], "citizens": [ { "voted": False, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, False ], "locks_cit": [ True, False, False ] }, number_of_spawned_threads: 4, threads_executed: 3 }
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, { "result": None }]

Step 1070:
  program counter:   1019
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=22 column=9
  end statement:     line=22 column=48
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e]

Step 1071:
  program counter:   1020
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted = True
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e, "citizens"]

Step 1072:
  program counter:   1021
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"]]

Step 1073:
  program counter:   1022
  hvm code:          LoadVar citizen
  explanation:       push value (0) of variable "citizen"
  source code:       election->citizens[citizen].voted = True
                                        ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"], 0]

Step 1074:
  program counter:   1023
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["citizens"]) and push the combined address (?e["citizens"][0])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0]]

Step 1075:
  program counter:   1024
  hvm code:          Push "voted"
  explanation:       push constant "voted"
  source code:       election->citizens[citizen].voted = True
                                                ^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0], "voted"]

Step 1076:
  program counter:   1025
  hvm code:          Address
  explanation:       pop a key ("voted") and an address (?e["citizens"][0]) and push the combined address (?e["citizens"][0]["voted"])
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0]["voted"]]

Step 1077:
  program counter:   1026
  hvm code:          Push True
  explanation:       push constant True
  source code:       election->citizens[citizen].voted = True
                                                         ^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0]["voted"], True]

Step 1078:
  program counter:   1027
  hvm code:          Store
  explanation:       pop value (True) and address (?e["citizens"][0]["voted"]) and store
  source code:       election->citizens[citizen].voted = True
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 2 ], "citizens": [ { "voted": True, "voted_for": -1 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, False ], "locks_cit": [ True, False, False ] }, number_of_spawned_threads: 4, threads_executed: 3 }
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, { "result": None }]

Step 1079:
  program counter:   1028
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=23 column=9
  end statement:     line=23 column=57
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e]

Step 1080:
  program counter:   1029
  hvm code:          Push "citizens"
  explanation:       push constant "citizens"
  source code:       election->citizens[citizen].voted_for = candidate
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e, "citizens"]

Step 1081:
  program counter:   1030
  hvm code:          Address
  explanation:       pop a key ("citizens") and an address (?e) and push the combined address (?e["citizens"])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"]]

Step 1082:
  program counter:   1031
  hvm code:          LoadVar citizen
  explanation:       push value (0) of variable "citizen"
  source code:       election->citizens[citizen].voted_for = candidate
                                        ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"], 0]

Step 1083:
  program counter:   1032
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["citizens"]) and push the combined address (?e["citizens"][0])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0]]

Step 1084:
  program counter:   1033
  hvm code:          Push "voted_for"
  explanation:       push constant "voted_for"
  source code:       election->citizens[citizen].voted_for = candidate
                                                ^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0], "voted_for"]

Step 1085:
  program counter:   1034
  hvm code:          Address
  explanation:       pop a key ("voted_for") and an address (?e["citizens"][0]) and push the combined address (?e["citizens"][0]["voted_for"])
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0]["voted_for"]]

Step 1086:
  program counter:   1035
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       election->citizens[citizen].voted_for = candidate
                                                             ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, ?e["citizens"][0]["voted_for"], 0]

Step 1087:
  program counter:   1036
  hvm code:          Store
  explanation:       pop value (0) and address (?e["citizens"][0]["voted_for"]) and store
  source code:       election->citizens[citizen].voted_for = candidate
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 2 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, False ], "locks_cit": [ True, False, False ] }, number_of_spawned_threads: 4, threads_executed: 3 }
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, { "result": None }]

Step 1088:
  program counter:   1037
  hvm code:          Push True
  explanation:       push constant True
  start statement:   line=24 column=9
  end statement:     line=24 column=21
  source code:       result = True
                              ^^^^
  stack:             [{:}, 21426, { "result": None }, True]

Step 1089:
  program counter:   1038
  hvm code:          StoreVar result
  explanation:       pop value (True) and store locally in variable "result"
  source code:       result = True
                     ^^^^^^^^
  method variables:  { candidate: 0, citizen: 0, election: ?e, result: True }
  stack:             [{:}, 21426, { "result": None }]

Step 1090:
  program counter:   1039
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=25 column=5
  end statement:     line=25 column=18
  source code:       result = False
                              ^^^^^
  method variables:  { candidate: 0, citizen: 0, election: ?e }

Step 1091:
  program counter:   1040
  hvm code:          Push False
  explanation:       push constant False
  start expression:  line=25 column=14
  end expression:    line=25 column=18
  stack:             [{:}, 21426, { "result": None }, False]

Step 1092:
  program counter:   1041
  hvm code:          StoreVar result
  explanation:       pop value (False) and store locally in variable "result"
  source code:       result = False
                     ^^^^^^^^
  method variables:  { candidate: 0, citizen: 0, election: ?e, result: False }
  stack:             [{:}, 21426, { "result": None }]

Step 1093:
  program counter:   1042
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714)]

Step 1094:
  program counter:   1043
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e]

Step 1095:
  program counter:   1044
  hvm code:          Push "locks_cit"
  explanation:       push constant "locks_cit"
  source code:       release(?(election->locks_cit[citizen]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e, "locks_cit"]

Step 1096:
  program counter:   1045
  hvm code:          Address
  explanation:       pop a key ("locks_cit") and an address (?e) and push the combined address (?e["locks_cit"])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_cit"]]

Step 1097:
  program counter:   1046
  hvm code:          LoadVar citizen
  explanation:       push value (0) of variable "citizen"
  source code:       release(?(election->locks_cit[citizen]))
                                                   ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_cit"], 0]

Step 1098:
  program counter:   1047
  hvm code:          DelVar citizen
  explanation:       delete method variable citizen
  start expression:  line=28 column=35
  end expression:    line=28 column=41
  method variables:  { candidate: 0, election: ?e, result: False }

Step 1099:
  program counter:   1048
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_cit"]) and push the combined address (?e["locks_cit"][0])
  source code:       release(?(election->locks_cit[citizen]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_cit"][0]]

Step 1100:
  program counter:   1049
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_cit"][0]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0) --> release(?e["locks_cit"][0])
  stack:             [{:}, 21426, { "result": None }, 16802, ?e["locks_cit"][0]]

Step 1101:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_cit"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_cit"][0], result: None }
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 0, "election": ?e, "result": False }]

Step 1102:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0) --> release(?e["locks_cit"][0])

Step 1103:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1104:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1105:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][0]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 0, "election": ?e, "result": False }, ?e["locks_cit"][0]]

Step 1106:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_cit"][0]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 0, "election": ?e, "result": False }, True]

Step 1107:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 0, "election": ?e, "result": False }]

Step 1108:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1109:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1110:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_cit"][0]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 0, "election": ?e, "result": False }, ?e["locks_cit"][0]]

Step 1111:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 1112:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 0, "election": ?e, "result": False }, ?e["locks_cit"][0], False]

Step 1113:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_cit"][0]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 2 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 3 }
  stack:             [{:}, 21426, { "result": None }, 16802, { "candidate": 0, "election": ?e, "result": False }]

Step 1114:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1115:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, election: ?e, result: False }
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, { "result": None }, None]

Step 1116:
  program counter:   1050
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=28 column=5
  end statement:     line=28 column=44
  source code:       release(?(election->locks_cit[citizen]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 1117:
  program counter:   1051
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714)]

Step 1118:
  program counter:   1052
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e]

Step 1119:
  program counter:   1053
  hvm code:          DelVar election
  explanation:       delete method variable election
  start expression:  line=29 column=15
  end expression:    line=29 column=22
  method variables:  { candidate: 0, result: False }

Step 1120:
  program counter:   1054
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e, "locks_can"]

Step 1121:
  program counter:   1055
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_can"]]

Step 1122:
  program counter:   1056
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       release(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_can"], 0]

Step 1123:
  program counter:   1057
  hvm code:          DelVar candidate
  explanation:       delete method variable candidate
  start expression:  line=29 column=35
  end expression:    line=29 column=43
  method variables:  { result: False }

Step 1124:
  program counter:   1058
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, PC(714), ?e["locks_can"][0]]

Step 1125:
  program counter:   1059
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0) --> release(?e["locks_can"][0])
  stack:             [{:}, 21426, { "result": None }, 16962, ?e["locks_can"][0]]

Step 1126:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }]

Step 1127:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0) --> release(?e["locks_can"][0])

Step 1128:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1129:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1130:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, ?e["locks_can"][0]]

Step 1131:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, True]

Step 1132:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }]

Step 1133:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1134:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1135:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, ?e["locks_can"][0]]

Step 1136:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 1137:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }, ?e["locks_can"][0], False]

Step 1138:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][0]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 2 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 3 }
  stack:             [{:}, 21426, { "result": None }, 16962, { "result": False }]

Step 1139:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1140:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: False }
  call trace:        test_vote(?e, 0, 0) --> vote(?e, 0, 0)
  stack:             [{:}, 21426, { "result": None }, None]

Step 1141:
  program counter:   1060
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=29 column=5
  end statement:     line=29 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21426, { "result": None }]

Step 1142:
  program counter:   1061
  hvm code:          Return
  explanation:       push result (False) and restore method variables
  start statement:   line=14 column=1
  end statement:     line=14 column=39
  source code:       def vote(election, candidate, citizen):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        test_vote(?e, 0, 0)
  stack:             [{:}, False]

Step 1143:
  program counter:   1339
  hvm code:          Pop
  explanation:       pop and discard value (False)
  file:              electiontest.hny
  start statement:   line=19 column=5
  end statement:     line=19 column=48
  source code:       election.vote(e, candidate_idx, citizen_idx)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 1144:
  program counter:   1340
  hvm code:          Push PC(1317)
  explanation:       push program counter constant 1317 ("complete")
  start statement:   line=20 column=5
  end statement:     line=20 column=14
  source code:       complete()
                     ^^^^^^^^
  stack:             [{:}, PC(1317)]

Step 1145:
  program counter:   1341
  hvm code:          Push ()
  explanation:       push constant ()
  source code:       complete()
                             ^^
  stack:             [{:}, PC(1317), []]

Step 1146:
  program counter:   1342
  hvm code:          Apply
  explanation:       pop an argument ([]) and a program counter value (1317: "complete") and call the method
  source code:       complete()
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0) --> complete()
  stack:             [{:}, 21490, []]

Step 1147:
  program counter:   1317
  hvm code:          Frame complete()
  explanation:       method "complete" with argument () set to []
  start statement:   line=14 column=1
  end statement:     line=14 column=15
  source code:       def complete():
                     ^^^^^^^^^^^^^^^
  stack:             [{:}, 21490, { "result": None }]

Step 1148:
  program counter:   1318
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=15 column=5
  end statement:     line=15 column=15
  source code:       atomically:
                     ^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0) --> complete()

Step 1149:
  program counter:   1319
  hvm code:          Load threads_executed
  explanation:       push value (3) of variable threads_executed
  start statement:   line=16 column=9
  end statement:     line=16 column=29
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21490, { "result": None }, 3]

Step 1150:
  program counter:   1320
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       threads_executed += 1
                                         ^
  stack:             [{:}, 21490, { "result": None }, 3, 1]

Step 1151:
  program counter:   1321
  hvm code:          2-ary +
  explanation:       pop 2 values (1, 3); add the integers; push result (4)
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 21490, { "result": None }, 4]

Step 1152:
  program counter:   1322
  hvm code:          Store threads_executed
  explanation:       pop value (4) and store into variable threads_executed
  source code:       threads_executed += 1
                     ^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 2 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, 21490, { "result": None }]

Step 1153:
  program counter:   1323
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 1 to 0: no longer atomic
  start statement:   line=15 column=5
  end statement:     line=15 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1154:
  program counter:   1324
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=14 column=1
  end statement:     line=14 column=15
  source code:       def complete():
                     ^^^^^^^^^^^^^^^
  call trace:        test_vote(?e, 0, 0)
  stack:             [{:}, None]

Step 1155:
  program counter:   1343
  hvm code:          Pop
  explanation:       pop and discard value (None)
  start statement:   line=20 column=5
  end statement:     line=20 column=14
  source code:       complete()
                     ^^^^^^^^^^
  stack:             [{:}]

Step 1156:
  program counter:   1344
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=18 column=1
  end statement:     line=18 column=45
  source code:       def test_vote(e, candidate_idx, citizen_idx):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { }
  new mode:          terminated
  stack:             []

================================================
Running thread T5: end_test()
mode:  runnable
stack: ['[]']
other threads:
  T0: pc=1501 terminated atomic __init__()
  T1: pc=1344 terminated test_vote(?e, 0, 0)
  T2: pc=1344 terminated test_vote(?e, 1, 1)
  T3: pc=1344 terminated test_vote(?e, 1, 1)
  T4: pc=1383 terminated test_withdraw(?e, 0, 1, 2)
shared variables:
  EXPECTED_VOTES: [ 3, 0 ]
  NUM_CANDIDATES: 2
  NUM_CITIZENS: 3
  WINNER: 0
  e: { "candidates": [ 1, 2 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }
  number_of_spawned_threads: 4
  threads_executed: 4
state id: 13152
================================================

Step 1157:
  program counter:   1385
  hvm code:          Frame end_test()
  explanation:       method "end_test" with argument () set to []
  start statement:   line=28 column=1
  end statement:     line=28 column=15
  source code:       def end_test():
                     ^^^^^^^^^^^^^^^
  method variables:  { result: None }
  call trace:        end_test()
  stack:             [{:}]

Step 1158:
  program counter:   1386
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 0 to 1: becomes atomic
  start statement:   line=29 column=16
  end statement:     line=38 column=6
  source code:       atomically when threads_executed == number_of_spawned_threads:
  call trace:        end_test()

Step 1159:
  program counter:   1387
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=29 column=16
  end expression:    line=29 column=16

Step 1160:
  program counter:   1388
  hvm code:          Load threads_executed
  explanation:       push value (4) of variable threads_executed
  start statement:   line=29 column=16
  end statement:     line=29 column=65
  source code:       atomically when threads_executed == number_of_spawned_threads:
                                     ^^^^^^^^^^^^^^^^
  stack:             [{:}, 4]

Step 1161:
  program counter:   1389
  hvm code:          Load number_of_spawned_threads
  explanation:       push value (4) of variable number_of_spawned_threads
  source code:       atomically when threads_executed == number_of_spawned_threads:
                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 4, 4]

Step 1162:
  program counter:   1390
  hvm code:          2-ary ==
  explanation:       pop 2 values (4, 4); check if both values are the same; push result (True)
  source code:       atomically when threads_executed == number_of_spawned_threads:
                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, True]

Step 1163:
  program counter:   1391
  hvm code:          JumpCond False 1393
  explanation:       pop value (True), compare to False, and jump to 1393 if the same
  source code:       atomically when threads_executed == number_of_spawned_threads:
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 1164:
  program counter:   1392
  hvm code:          Jump 1396
  explanation:       set program counter to 1396
  source code:       atomically when threads_executed == number_of_spawned_threads:
                                                                                 ^

Step 1165:
  program counter:   1396
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when threads_executed == number_of_spawned_threads:
                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1166:
  program counter:   1397
  hvm code:          Push PC(1200)
  explanation:       push program counter constant 1200 ("transfer")
  start statement:   line=31 column=9
  end statement:     line=31 column=35
  source code:       election.transfer(?e, 1, 0)
                     ^^^^^^^^^^^^^^^^^
  stack:             [{:}, PC(1200)]

Step 1167:
  program counter:   1398
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       election.transfer(?e, 1, 0)
                                       ^^^^^^^^
  stack:             [{:}, PC(1200), []]

Step 1168:
  program counter:   1399
  hvm code:          Push ?e
  explanation:       push constant ?e
  source code:       election.transfer(?e, 1, 0)
                                        ^
  stack:             [{:}, PC(1200), [], ?e]

Step 1169:
  program counter:   1400
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       election.transfer(?e, 1, 0)
                                       ^^^^^^^^
  stack:             [{:}, PC(1200), [ ?e ]]

Step 1170:
  program counter:   1401
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       election.transfer(?e, 1, 0)
                                           ^
  stack:             [{:}, PC(1200), [ ?e ], 1]

Step 1171:
  program counter:   1402
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e]); insert first value into the second; push result ([?e, 1])
  source code:       election.transfer(?e, 1, 0)
                                       ^^^^^^^^
  stack:             [{:}, PC(1200), [ ?e, 1 ]]

Step 1172:
  program counter:   1403
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       election.transfer(?e, 1, 0)
                                              ^
  stack:             [{:}, PC(1200), [ ?e, 1 ], 0]

Step 1173:
  program counter:   1404
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [?e, 1]); insert first value into the second; push result ([?e, 1, 0])
  source code:       election.transfer(?e, 1, 0)
                                       ^^^^^^^^
  stack:             [{:}, PC(1200), [ ?e, 1, 0 ]]

Step 1174:
  program counter:   1405
  hvm code:          Apply
  explanation:       pop an argument ([?e, 1, 0]) and a program counter value (1200: "transfer") and call the method
  source code:       election.transfer(?e, 1, 0)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> transfer(?e, 1, 0)
  stack:             [{:}, 22498, [ ?e, 1, 0 ]]

Step 1175:
  program counter:   1200
  hvm code:          Frame transfer(election, candidate_from, candidate_to)
  explanation:       method "transfer" with argument (election, candidate_from, candidate_to) set to [?e, 1, 0]
  file:              electionimpl.hny
  start statement:   line=64 column=1
  end statement:     line=64 column=53
  source code:       def transfer(election, candidate_from, candidate_to):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate_from: 1, candidate_to: 0, election: ?e, result: None }
  stack:             [{:}, 22498, { "result": None }]

Step 1176:
  program counter:   1201
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=66 column=5
  end statement:     line=66 column=51
  source code:       acquire(?(election->locks_can[candidate_from]))
                     ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695)]

Step 1177:
  program counter:   1202
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate_from]))
                               ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e]

Step 1178:
  program counter:   1203
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate_from]))
                                         ^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e, "locks_can"]

Step 1179:
  program counter:   1204
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate_from]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e["locks_can"]]

Step 1180:
  program counter:   1205
  hvm code:          LoadVar candidate_from
  explanation:       push value (1) of variable "candidate_from"
  source code:       acquire(?(election->locks_can[candidate_from]))
                                                   ^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e["locks_can"], 1]

Step 1181:
  program counter:   1206
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       acquire(?(election->locks_can[candidate_from]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e["locks_can"][1]]

Step 1182:
  program counter:   1207
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate_from]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> transfer(?e, 1, 0) --> acquire(?e["locks_can"][1])
  stack:             [{:}, 22498, { "result": None }, 19330, ?e["locks_can"][1]]

Step 1183:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, 22498, { "result": None }, 19330, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }]

Step 1184:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:

Step 1185:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 1186:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19330, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, ?e["locks_can"][1]]

Step 1187:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19330, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, False]

Step 1188:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19330, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, True]

Step 1189:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19330, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }]

Step 1190:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 1191:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1192:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19330, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, ?e["locks_can"][1]]

Step 1193:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 1194:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 22498, { "result": None }, 19330, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, ?e["locks_can"][1], True]

Step 1195:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][1]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 2 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, 22498, { "result": None }, 19330, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }]

Step 1196:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1197:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate_from: 1, candidate_to: 0, election: ?e, result: None }
  call trace:        end_test() --> transfer(?e, 1, 0)
  stack:             [{:}, 22498, { "result": None }, None]

Step 1198:
  program counter:   1208
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=66 column=5
  end statement:     line=66 column=51
  source code:       acquire(?(election->locks_can[candidate_from]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }]

Step 1199:
  program counter:   1209
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start statement:   line=67 column=5
  end statement:     line=67 column=49
  source code:       acquire(?(election->locks_can[candidate_to]))
                     ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695)]

Step 1200:
  program counter:   1210
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate_to]))
                               ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e]

Step 1201:
  program counter:   1211
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate_to]))
                                         ^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e, "locks_can"]

Step 1202:
  program counter:   1212
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate_to]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e["locks_can"]]

Step 1203:
  program counter:   1213
  hvm code:          LoadVar candidate_to
  explanation:       push value (0) of variable "candidate_to"
  source code:       acquire(?(election->locks_can[candidate_to]))
                                                   ^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e["locks_can"], 0]

Step 1204:
  program counter:   1214
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       acquire(?(election->locks_can[candidate_to]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(695), ?e["locks_can"][0]]

Step 1205:
  program counter:   1215
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate_to]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> transfer(?e, 1, 0) --> acquire(?e["locks_can"][0])
  stack:             [{:}, 22498, { "result": None }, 19458, ?e["locks_can"][0]]

Step 1206:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, 22498, { "result": None }, 19458, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }]

Step 1207:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:

Step 1208:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 1209:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19458, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, ?e["locks_can"][0]]

Step 1210:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19458, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, False]

Step 1211:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19458, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, True]

Step 1212:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19458, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }]

Step 1213:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 1214:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1215:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19458, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, ?e["locks_can"][0]]

Step 1216:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 1217:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, 22498, { "result": None }, 19458, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }, ?e["locks_can"][0], True]

Step 1218:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][0]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 1, 2 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, 22498, { "result": None }, 19458, { "candidate_from": 1, "candidate_to": 0, "election": ?e, "result": None }]

Step 1219:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1220:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate_from: 1, candidate_to: 0, election: ?e, result: None }
  call trace:        end_test() --> transfer(?e, 1, 0)
  stack:             [{:}, 22498, { "result": None }, None]

Step 1221:
  program counter:   1216
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=67 column=5
  end statement:     line=67 column=49
  source code:       acquire(?(election->locks_can[candidate_to]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }]

Step 1222:
  program counter:   1217
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=69 column=5
  end statement:     line=69 column=78
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                     ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e]

Step 1223:
  program counter:   1218
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                               ^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e, "candidates"]

Step 1224:
  program counter:   1219
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                     ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"]]

Step 1225:
  program counter:   1220
  hvm code:          LoadVar candidate_to
  explanation:       push value (0) of variable "candidate_to"
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                                          ^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"], 0]

Step 1226:
  program counter:   1221
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["candidates"]) and push the combined address (?e["candidates"][0])
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0]]

Step 1227:
  program counter:   1222
  hvm code:          Dup
  explanation:       push a copy of the top value on the stack
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0], ?e["candidates"][0]]

Step 1228:
  program counter:   1223
  hvm code:          Load
  explanation:       pop address of variable (?e["candidates"][0]) and push value (1)
  start expression:  line=69 column=5
  end expression:    line=69 column=78
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0], 1]

Step 1229:
  program counter:   1224
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                                                           ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0], 1, ?e]

Step 1230:
  program counter:   1225
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                                                                     ^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0], 1, ?e, "candidates"]

Step 1231:
  program counter:   1226
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                                                           ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0], 1, ?e["candidates"]]

Step 1232:
  program counter:   1227
  hvm code:          LoadVar candidate_from
  explanation:       push value (1) of variable "candidate_from"
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                                                                                ^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0], 1, ?e["candidates"], 1]

Step 1233:
  program counter:   1228
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["candidates"]) and push the combined address (?e["candidates"][1])
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0], 1, ?e["candidates"][1]]

Step 1234:
  program counter:   1229
  hvm code:          Load
  explanation:       pop address of variable (?e["candidates"][1]) and push value (2)
  start expression:  line=69 column=43
  end expression:    line=69 column=78
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0], 1, 2]

Step 1235:
  program counter:   1230
  hvm code:          2-ary +
  explanation:       pop 2 values (2, 1); add the integers; push result (3)
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][0], 3]

Step 1236:
  program counter:   1231
  hvm code:          Store
  explanation:       pop value (3) and address (?e["candidates"][0]) and store
  source code:       election->candidates[candidate_to] += election->candidates[candidate_from]
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 3, 2 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, 22498, { "result": None }]

Step 1237:
  program counter:   1232
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=70 column=5
  end statement:     line=70 column=44
  source code:       election->candidates[candidate_from] = 0
                     ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e]

Step 1238:
  program counter:   1233
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       election->candidates[candidate_from] = 0
                               ^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e, "candidates"]

Step 1239:
  program counter:   1234
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       election->candidates[candidate_from] = 0
                     ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"]]

Step 1240:
  program counter:   1235
  hvm code:          LoadVar candidate_from
  explanation:       push value (1) of variable "candidate_from"
  source code:       election->candidates[candidate_from] = 0
                                          ^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"], 1]

Step 1241:
  program counter:   1236
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["candidates"]) and push the combined address (?e["candidates"][1])
  source code:       election->candidates[candidate_from] = 0
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][1]]

Step 1242:
  program counter:   1237
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       election->candidates[candidate_from] = 0
                                                            ^
  stack:             [{:}, 22498, { "result": None }, ?e["candidates"][1], 0]

Step 1243:
  program counter:   1238
  hvm code:          Store
  explanation:       pop value (0) and address (?e["candidates"][1]) and store
  source code:       election->candidates[candidate_from] = 0
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 3, 0 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, 22498, { "result": None }]

Step 1244:
  program counter:   1239
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=73 column=5
  end statement:     line=73 column=51
  source code:       release(?(election->locks_can[candidate_from]))
                     ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714)]

Step 1245:
  program counter:   1240
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate_from]))
                               ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e]

Step 1246:
  program counter:   1241
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate_from]))
                                         ^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e, "locks_can"]

Step 1247:
  program counter:   1242
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate_from]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e["locks_can"]]

Step 1248:
  program counter:   1243
  hvm code:          LoadVar candidate_from
  explanation:       push value (1) of variable "candidate_from"
  source code:       release(?(election->locks_can[candidate_from]))
                                                   ^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e["locks_can"], 1]

Step 1249:
  program counter:   1244
  hvm code:          DelVar candidate_from
  explanation:       delete method variable candidate_from
  start expression:  line=73 column=35
  end expression:    line=73 column=48
  method variables:  { candidate_to: 0, election: ?e, result: None }

Step 1250:
  program counter:   1245
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       release(?(election->locks_can[candidate_from]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e["locks_can"][1]]

Step 1251:
  program counter:   1246
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate_from]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> transfer(?e, 1, 0) --> release(?e["locks_can"][1])
  stack:             [{:}, 22498, { "result": None }, 19954, ?e["locks_can"][1]]

Step 1252:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, 22498, { "result": None }, 19954, { "candidate_to": 0, "election": ?e, "result": None }]

Step 1253:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^

Step 1254:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1255:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 2 to 3: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1256:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19954, { "candidate_to": 0, "election": ?e, "result": None }, ?e["locks_can"][1]]

Step 1257:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19954, { "candidate_to": 0, "election": ?e, "result": None }, True]

Step 1258:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19954, { "candidate_to": 0, "election": ?e, "result": None }]

Step 1259:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 3 to 2: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1260:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1261:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 19954, { "candidate_to": 0, "election": ?e, "result": None }, ?e["locks_can"][1]]

Step 1262:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 1263:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 22498, { "result": None }, 19954, { "candidate_to": 0, "election": ?e, "result": None }, ?e["locks_can"][1], False]

Step 1264:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][1]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 3, 0 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, 22498, { "result": None }, 19954, { "candidate_to": 0, "election": ?e, "result": None }]

Step 1265:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1266:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate_to: 0, election: ?e, result: None }
  call trace:        end_test() --> transfer(?e, 1, 0)
  stack:             [{:}, 22498, { "result": None }, None]

Step 1267:
  program counter:   1247
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=73 column=5
  end statement:     line=73 column=51
  source code:       release(?(election->locks_can[candidate_from]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }]

Step 1268:
  program counter:   1248
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=74 column=5
  end statement:     line=74 column=49
  source code:       release(?(election->locks_can[candidate_to]))
                     ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714)]

Step 1269:
  program counter:   1249
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate_to]))
                               ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e]

Step 1270:
  program counter:   1250
  hvm code:          DelVar election
  explanation:       delete method variable election
  start expression:  line=74 column=15
  end expression:    line=74 column=22
  method variables:  { candidate_to: 0, result: None }

Step 1271:
  program counter:   1251
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate_to]))
                                         ^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e, "locks_can"]

Step 1272:
  program counter:   1252
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate_to]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e["locks_can"]]

Step 1273:
  program counter:   1253
  hvm code:          LoadVar candidate_to
  explanation:       push value (0) of variable "candidate_to"
  source code:       release(?(election->locks_can[candidate_to]))
                                                   ^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e["locks_can"], 0]

Step 1274:
  program counter:   1254
  hvm code:          DelVar candidate_to
  explanation:       delete method variable candidate_to
  start expression:  line=74 column=35
  end expression:    line=74 column=46
  method variables:  { result: None }

Step 1275:
  program counter:   1255
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       release(?(election->locks_can[candidate_to]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, PC(714), ?e["locks_can"][0]]

Step 1276:
  program counter:   1256
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate_to]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> transfer(?e, 1, 0) --> release(?e["locks_can"][0])
  stack:             [{:}, 22498, { "result": None }, 20114, ?e["locks_can"][0]]

Step 1277:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, 22498, { "result": None }, 20114, { "result": None }]

Step 1278:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^

Step 1279:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1280:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 2 to 3: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1281:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 20114, { "result": None }, ?e["locks_can"][0]]

Step 1282:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 20114, { "result": None }, True]

Step 1283:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, 22498, { "result": None }, 20114, { "result": None }]

Step 1284:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 3 to 2: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1285:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1286:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, 22498, { "result": None }, 20114, { "result": None }, ?e["locks_can"][0]]

Step 1287:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 1288:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, 22498, { "result": None }, 20114, { "result": None }, ?e["locks_can"][0], False]

Step 1289:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][0]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 3, 0 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, 22498, { "result": None }, 20114, { "result": None }]

Step 1290:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1291:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> transfer(?e, 1, 0)
  stack:             [{:}, 22498, { "result": None }, None]

Step 1292:
  program counter:   1257
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=74 column=5
  end statement:     line=74 column=49
  source code:       release(?(election->locks_can[candidate_to]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, 22498, { "result": None }]

Step 1293:
  program counter:   1258
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=64 column=1
  end statement:     line=64 column=53
  source code:       def transfer(election, candidate_from, candidate_to):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test()
  stack:             [{:}, None]

Step 1294:
  program counter:   1406
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electiontest.hny
  start statement:   line=31 column=9
  end statement:     line=31 column=35
  source code:       election.transfer(?e, 1, 0)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}]

Step 1295:
  program counter:   1407
  hvm code:          Push {}
  explanation:       push constant {}
  start statement:   line=32 column=9
  end statement:     line=32 column=39
  source code:       for i in {0, NUM_CANDIDATES -1}:
                               ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, {}]

Step 1296:
  program counter:   1408
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {0, NUM_CANDIDATES -1}:
                               ^
  stack:             [{:}, {}, 0]

Step 1297:
  program counter:   1409
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (0, {}); insert first value into the second; push result ({ 0 })
  source code:       for i in {0, NUM_CANDIDATES -1}:
                               ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0 }]

Step 1298:
  program counter:   1410
  hvm code:          Load NUM_CANDIDATES
  explanation:       push value (2) of variable NUM_CANDIDATES
  source code:       for i in {0, NUM_CANDIDATES -1}:
                                  ^^^^^^^^^^^^^^
  stack:             [{:}, { 0 }, 2]

Step 1299:
  program counter:   1411
  hvm code:          Push 1
  explanation:       push constant 1
  source code:       for i in {0, NUM_CANDIDATES -1}:
                                                  ^
  stack:             [{:}, { 0 }, 2, 1]

Step 1300:
  program counter:   1412
  hvm code:          2-ary -
  explanation:       pop 2 values (1, 2); the second integer minus the first; push result (1)
  source code:       for i in {0, NUM_CANDIDATES -1}:
                                  ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0 }, 1]

Step 1301:
  program counter:   1413
  hvm code:          2-ary SetAdd
  explanation:       pop 2 values (1, { 0 }); insert first value into the second; push result ({ 0, 1 })
  source code:       for i in {0, NUM_CANDIDATES -1}:
                               ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }]

Step 1302:
  program counter:   1414
  hvm code:          Push 0
  explanation:       push constant 0
  source code:       for i in {0, NUM_CANDIDATES -1}:
                     ^^^
  stack:             [{:}, { 0, 1 }, 0]

Step 1303:
  program counter:   1415
  hvm code:          Cut(i)
  explanation:       pop index (0) and value ({ 0, 1 }); assign value (0) to i; push new index (1) and True
  start expression:  line=32 column=9
  end expression:    line=32 column=11
  method variables:  { i: 0, result: None }
  stack:             [{:}, { 0, 1 }, 1, True]

Step 1304:
  program counter:   1416
  hvm code:          JumpCond False 1439
  explanation:       pop value (True), compare to False, and jump to 1439 if the same
  start expression:  line=32 column=9
  end expression:    line=32 column=11
  stack:             [{:}, { 0, 1 }, 1]

Step 1305:
  program counter:   1417
  hvm code:          Push PC(1171)
  explanation:       push program counter constant 1171 ("get_votes")
  start statement:   line=33 column=13
  end statement:     line=33 column=58
  source code:       let received_votes = election.get_votes(?e, i):
                                          ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, PC(1171)]

Step 1306:
  program counter:   1418
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       let received_votes = election.get_votes(?e, i):
                                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 1, PC(1171), []]

Step 1307:
  program counter:   1419
  hvm code:          Push ?e
  explanation:       push constant ?e
  source code:       let received_votes = election.get_votes(?e, i):
                                                              ^
  stack:             [{:}, { 0, 1 }, 1, PC(1171), [], ?e]

Step 1308:
  program counter:   1420
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       let received_votes = election.get_votes(?e, i):
                                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 1, PC(1171), [ ?e ]]

Step 1309:
  program counter:   1421
  hvm code:          LoadVar i
  explanation:       push value (0) of variable "i"
  source code:       let received_votes = election.get_votes(?e, i):
                                                                 ^
  stack:             [{:}, { 0, 1 }, 1, PC(1171), [ ?e ], 0]

Step 1310:
  program counter:   1422
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (0, [?e]); insert first value into the second; push result ([?e, 0])
  source code:       let received_votes = election.get_votes(?e, i):
                                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 1, PC(1171), [ ?e, 0 ]]

Step 1311:
  program counter:   1423
  hvm code:          Apply
  explanation:       pop an argument ([?e, 0]) and a program counter value (1171: "get_votes") and call the method
  source code:       let received_votes = election.get_votes(?e, i):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> get_votes(?e, 0)
  stack:             [{:}, { 0, 1 }, 1, 22786, [ ?e, 0 ]]

Step 1312:
  program counter:   1171
  hvm code:          Frame get_votes(election, candidate)
  explanation:       method "get_votes" with argument (election, candidate) set to [?e, 0]
  file:              electionimpl.hny
  start statement:   line=54 column=1
  end statement:     line=54 column=35
  source code:       def get_votes(election, candidate):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, election: ?e, result: None }
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }]

Step 1313:
  program counter:   1172
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=56 column=5
  end statement:     line=56 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^
  method variables:  { candidate: 0, election: ?e }

Step 1314:
  program counter:   1173
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start expression:  line=56 column=5
  end expression:    line=56 column=11
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(695)]

Step 1315:
  program counter:   1174
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(695), ?e]

Step 1316:
  program counter:   1175
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(695), ?e, "locks_can"]

Step 1317:
  program counter:   1176
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(695), ?e["locks_can"]]

Step 1318:
  program counter:   1177
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       acquire(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(695), ?e["locks_can"], 0]

Step 1319:
  program counter:   1178
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(695), ?e["locks_can"][0]]

Step 1320:
  program counter:   1179
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> get_votes(?e, 0) --> acquire(?e["locks_can"][0])
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 18882, ?e["locks_can"][0]]

Step 1321:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 18882, { "candidate": 0, "election": ?e }]

Step 1322:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:

Step 1323:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 1324:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 18882, { "candidate": 0, "election": ?e }, ?e["locks_can"][0]]

Step 1325:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 18882, { "candidate": 0, "election": ?e }, False]

Step 1326:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 18882, { "candidate": 0, "election": ?e }, True]

Step 1327:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 18882, { "candidate": 0, "election": ?e }]

Step 1328:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 1329:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1330:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 18882, { "candidate": 0, "election": ?e }, ?e["locks_can"][0]]

Step 1331:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 1332:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 18882, { "candidate": 0, "election": ?e }, ?e["locks_can"][0], True]

Step 1333:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][0]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 3, 0 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ True, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 18882, { "candidate": 0, "election": ?e }]

Step 1334:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1335:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 0, election: ?e }
  call trace:        end_test() --> get_votes(?e, 0)
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, None]

Step 1336:
  program counter:   1180
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=56 column=5
  end statement:     line=56 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }]

Step 1337:
  program counter:   1181
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=59 column=5
  end statement:     line=59 column=44
  source code:       result = election->candidates[candidate]
                              ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, ?e]

Step 1338:
  program counter:   1182
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       result = election->candidates[candidate]
                                        ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, ?e, "candidates"]

Step 1339:
  program counter:   1183
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       result = election->candidates[candidate]
                              ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, ?e["candidates"]]

Step 1340:
  program counter:   1184
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       result = election->candidates[candidate]
                                                   ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, ?e["candidates"], 0]

Step 1341:
  program counter:   1185
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["candidates"]) and push the combined address (?e["candidates"][0])
  source code:       result = election->candidates[candidate]
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, ?e["candidates"][0]]

Step 1342:
  program counter:   1186
  hvm code:          Load
  explanation:       pop address of variable (?e["candidates"][0]) and push value (3)
  start expression:  line=59 column=14
  end expression:    line=59 column=44
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 3]

Step 1343:
  program counter:   1187
  hvm code:          StoreVar result
  explanation:       pop value (3) and store locally in variable "result"
  source code:       result = election->candidates[candidate]
                     ^^^^^^^^
  method variables:  { candidate: 0, election: ?e, result: 3 }
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }]

Step 1344:
  program counter:   1188
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=62 column=5
  end statement:     line=62 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(714)]

Step 1345:
  program counter:   1189
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(714), ?e]

Step 1346:
  program counter:   1190
  hvm code:          DelVar election
  explanation:       delete method variable election
  start expression:  line=62 column=15
  end expression:    line=62 column=22
  method variables:  { candidate: 0, result: 3 }

Step 1347:
  program counter:   1191
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(714), ?e, "locks_can"]

Step 1348:
  program counter:   1192
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(714), ?e["locks_can"]]

Step 1349:
  program counter:   1193
  hvm code:          LoadVar candidate
  explanation:       push value (0) of variable "candidate"
  source code:       release(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(714), ?e["locks_can"], 0]

Step 1350:
  program counter:   1194
  hvm code:          DelVar candidate
  explanation:       delete method variable candidate
  start expression:  line=62 column=35
  end expression:    line=62 column=43
  method variables:  { result: 3 }

Step 1351:
  program counter:   1195
  hvm code:          Address
  explanation:       pop a key (0) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][0])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, PC(714), ?e["locks_can"][0]]

Step 1352:
  program counter:   1196
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][0]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> get_votes(?e, 0) --> release(?e["locks_can"][0])
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 19154, ?e["locks_can"][0]]

Step 1353:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][0]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][0], result: None }
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 19154, { "result": 3 }]

Step 1354:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^

Step 1355:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1356:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 2 to 3: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1357:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 19154, { "result": 3 }, ?e["locks_can"][0]]

Step 1358:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][0]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 19154, { "result": 3 }, True]

Step 1359:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 19154, { "result": 3 }]

Step 1360:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 3 to 2: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1361:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1362:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][0]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 19154, { "result": 3 }, ?e["locks_can"][0]]

Step 1363:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 1364:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 19154, { "result": 3 }, ?e["locks_can"][0], False]

Step 1365:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][0]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 3, 0 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, 19154, { "result": 3 }]

Step 1366:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1367:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: 3 }
  call trace:        end_test() --> get_votes(?e, 0)
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }, None]

Step 1368:
  program counter:   1197
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=62 column=5
  end statement:     line=62 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 22786, { "i": 0, "result": None }]

Step 1369:
  program counter:   1198
  hvm code:          Return
  explanation:       push result (3) and restore method variables
  start statement:   line=54 column=1
  end statement:     line=54 column=35
  source code:       def get_votes(election, candidate):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { i: 0, result: None }
  call trace:        end_test()
  stack:             [{:}, { 0, 1 }, 1, 3]

Step 1370:
  program counter:   1424
  hvm code:          StoreVar received_votes
  explanation:       pop value (3) and store locally in variable "received_votes"
  file:              electiontest.hny
  start statement:   line=33 column=13
  end statement:     line=33 column=58
  source code:       let received_votes = election.get_votes(?e, i):
                     ^^^^^^^^^^^^^^^^^^^^
  method variables:  { i: 0, received_votes: 3, result: None }
  stack:             [{:}, { 0, 1 }, 1]

Step 1371:
  program counter:   1425
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=34 column=17
  end statement:     line=34 column=58
  source code:       assert EXPECTED_VOTES[i] == received_votes
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1372:
  program counter:   1426
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=34 column=17
  end expression:    line=34 column=58

Step 1373:
  program counter:   1427
  hvm code:          Push ?EXPECTED_VOTES
  explanation:       push constant ?EXPECTED_VOTES
  source code:       assert EXPECTED_VOTES[i] == received_votes
                            ^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, ?EXPECTED_VOTES]

Step 1374:
  program counter:   1428
  hvm code:          LoadVar i
  explanation:       push value (0) of variable "i"
  source code:       assert EXPECTED_VOTES[i] == received_votes
                                           ^
  stack:             [{:}, { 0, 1 }, 1, ?EXPECTED_VOTES, 0]

Step 1375:
  program counter:   1429
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=34 column=39
  end expression:    line=34 column=39
  method variables:  { received_votes: 3, result: None }

Step 1376:
  program counter:   1430
  hvm code:          Address
  explanation:       pop a key (0) and an address (?EXPECTED_VOTES) and push the combined address (?EXPECTED_VOTES[0])
  source code:       assert EXPECTED_VOTES[i] == received_votes
                            ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, ?EXPECTED_VOTES[0]]

Step 1377:
  program counter:   1431
  hvm code:          Load
  explanation:       pop address of variable (?EXPECTED_VOTES[0]) and push value (3)
  start expression:  line=34 column=24
  end expression:    line=34 column=40
  stack:             [{:}, { 0, 1 }, 1, 3]

Step 1378:
  program counter:   1432
  hvm code:          LoadVar received_votes
  explanation:       push value (3) of variable "received_votes"
  source code:       assert EXPECTED_VOTES[i] == received_votes
                                                 ^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, 3, 3]

Step 1379:
  program counter:   1433
  hvm code:          DelVar received_votes
  explanation:       delete method variable received_votes
  start expression:  line=34 column=45
  end expression:    line=34 column=58
  method variables:  { result: None }

Step 1380:
  program counter:   1434
  hvm code:          2-ary ==
  explanation:       pop 2 values (3, 3); check if both values are the same; push result (True)
  source code:       assert EXPECTED_VOTES[i] == received_votes
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 1, True]

Step 1381:
  program counter:   1435
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert EXPECTED_VOTES[i] == received_votes
                     ^^^^^^
  stack:             [{:}, { 0, 1 }, 1]

Step 1382:
  program counter:   1436
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert EXPECTED_VOTES[i] == received_votes
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1383:
  program counter:   1437
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=34 column=17
  end expression:    line=34 column=58

Step 1384:
  program counter:   1438
  hvm code:          Jump 1415
  explanation:       set program counter to 1415
  start statement:   line=32 column=9
  end statement:     line=32 column=39
  source code:       for i in {0, NUM_CANDIDATES -1}:
                                                   ^

Step 1385:
  program counter:   1415
  hvm code:          Cut(i)
  explanation:       pop index (1) and value ({ 0, 1 }); assign value (1) to i; push new index (2) and True
  source code:       for i in {0, NUM_CANDIDATES -1}:
                     ^^^
  method variables:  { i: 1, result: None }
  stack:             [{:}, { 0, 1 }, 2, True]

Step 1386:
  program counter:   1416
  hvm code:          JumpCond False 1439
  explanation:       pop value (True), compare to False, and jump to 1439 if the same
  start expression:  line=32 column=9
  end expression:    line=32 column=11
  stack:             [{:}, { 0, 1 }, 2]

Step 1387:
  program counter:   1417
  hvm code:          Push PC(1171)
  explanation:       push program counter constant 1171 ("get_votes")
  start statement:   line=33 column=13
  end statement:     line=33 column=58
  source code:       let received_votes = election.get_votes(?e, i):
                                          ^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, PC(1171)]

Step 1388:
  program counter:   1418
  hvm code:          Push ()
  explanation:       building a tuple: push constant ()
  source code:       let received_votes = election.get_votes(?e, i):
                                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 2, PC(1171), []]

Step 1389:
  program counter:   1419
  hvm code:          Push ?e
  explanation:       push constant ?e
  source code:       let received_votes = election.get_votes(?e, i):
                                                              ^
  stack:             [{:}, { 0, 1 }, 2, PC(1171), [], ?e]

Step 1390:
  program counter:   1420
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (?e, []); insert first value into the second; push result ([?e])
  source code:       let received_votes = election.get_votes(?e, i):
                                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 2, PC(1171), [ ?e ]]

Step 1391:
  program counter:   1421
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       let received_votes = election.get_votes(?e, i):
                                                                 ^
  stack:             [{:}, { 0, 1 }, 2, PC(1171), [ ?e ], 1]

Step 1392:
  program counter:   1422
  hvm code:          2-ary ListAdd
  explanation:       pop 2 values (1, [?e]); insert first value into the second; push result ([?e, 1])
  source code:       let received_votes = election.get_votes(?e, i):
                                                             ^^^^^
  stack:             [{:}, { 0, 1 }, 2, PC(1171), [ ?e, 1 ]]

Step 1393:
  program counter:   1423
  hvm code:          Apply
  explanation:       pop an argument ([?e, 1]) and a program counter value (1171: "get_votes") and call the method
  source code:       let received_votes = election.get_votes(?e, i):
                                          ^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> get_votes(?e, 1)
  stack:             [{:}, { 0, 1 }, 2, 22786, [ ?e, 1 ]]

Step 1394:
  program counter:   1171
  hvm code:          Frame get_votes(election, candidate)
  explanation:       method "get_votes" with argument (election, candidate) set to [?e, 1]
  file:              electionimpl.hny
  start statement:   line=54 column=1
  end statement:     line=54 column=35
  source code:       def get_votes(election, candidate):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, election: ?e, result: None }
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }]

Step 1395:
  program counter:   1172
  hvm code:          DelVar result
  explanation:       delete method variable result
  start statement:   line=56 column=5
  end statement:     line=56 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^
  method variables:  { candidate: 1, election: ?e }

Step 1396:
  program counter:   1173
  hvm code:          Push PC(695)
  explanation:       push program counter constant 695 ("acquire")
  start expression:  line=56 column=5
  end expression:    line=56 column=11
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(695)]

Step 1397:
  program counter:   1174
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(695), ?e]

Step 1398:
  program counter:   1175
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       acquire(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(695), ?e, "locks_can"]

Step 1399:
  program counter:   1176
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(695), ?e["locks_can"]]

Step 1400:
  program counter:   1177
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       acquire(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(695), ?e["locks_can"], 1]

Step 1401:
  program counter:   1178
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       acquire(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(695), ?e["locks_can"][1]]

Step 1402:
  program counter:   1179
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (695: "acquire") and call the method
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> get_votes(?e, 1) --> acquire(?e["locks_can"][1])
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 18882, ?e["locks_can"][1]]

Step 1403:
  program counter:   695
  hvm code:          Frame acquire(binsema)
  explanation:       method "acquire" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 18882, { "candidate": 1, "election": ?e }]

Step 1404:
  program counter:   696
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=31 column=16
  end statement:     line=33 column=6
  source code:       atomically when not !binsema:

Step 1405:
  program counter:   697
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start expression:  line=31 column=16
  end expression:    line=31 column=16

Step 1406:
  program counter:   698
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                          ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 18882, { "candidate": 1, "election": ?e }, ?e["locks_can"][1]]

Step 1407:
  program counter:   699
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (False)
  source code:       atomically when not !binsema:
                                         ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 18882, { "candidate": 1, "election": ?e }, False]

Step 1408:
  program counter:   700
  hvm code:          1-ary not
  explanation:       pop a value (False); logical not; push result (True)
  source code:       atomically when not !binsema:
                                     ^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 18882, { "candidate": 1, "election": ?e }, True]

Step 1409:
  program counter:   701
  hvm code:          JumpCond False 703
  explanation:       pop value (True), compare to False, and jump to 703 if the same
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 18882, { "candidate": 1, "election": ?e }]

Step 1410:
  program counter:   702
  hvm code:          Jump 706
  explanation:       set program counter to 706
  source code:       atomically when not !binsema:
                                                ^

Step 1411:
  program counter:   706
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1412:
  program counter:   707
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=32 column=9
  end statement:     line=32 column=23
  source code:       !binsema = True
                      ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 18882, { "candidate": 1, "election": ?e }, ?e["locks_can"][1]]

Step 1413:
  program counter:   708
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=32 column=10
  end expression:    line=32 column=16
  method variables:  { result: None }

Step 1414:
  program counter:   709
  hvm code:          Push True
  explanation:       push constant True
  source code:       !binsema = True
                                ^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 18882, { "candidate": 1, "election": ?e }, ?e["locks_can"][1], True]

Step 1415:
  program counter:   710
  hvm code:          Store
  explanation:       pop value (True) and address (?e["locks_can"][1]) and store
  source code:       !binsema = True
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 3, 0 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, True ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 18882, { "candidate": 1, "election": ?e }]

Step 1416:
  program counter:   711
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start statement:   line=31 column=16
  end statement:     line=31 column=32
  source code:       atomically when not !binsema:
                                ^^^^^^^^^^^^^^^^^

Step 1417:
  program counter:   712
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=30 column=1
  end statement:     line=30 column=21
  source code:       def acquire(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { candidate: 1, election: ?e }
  call trace:        end_test() --> get_votes(?e, 1)
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, None]

Step 1418:
  program counter:   1180
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=56 column=5
  end statement:     line=56 column=46
  source code:       acquire(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }]

Step 1419:
  program counter:   1181
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  start statement:   line=59 column=5
  end statement:     line=59 column=44
  source code:       result = election->candidates[candidate]
                              ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, ?e]

Step 1420:
  program counter:   1182
  hvm code:          Push "candidates"
  explanation:       push constant "candidates"
  source code:       result = election->candidates[candidate]
                                        ^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, ?e, "candidates"]

Step 1421:
  program counter:   1183
  hvm code:          Address
  explanation:       pop a key ("candidates") and an address (?e) and push the combined address (?e["candidates"])
  source code:       result = election->candidates[candidate]
                              ^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, ?e["candidates"]]

Step 1422:
  program counter:   1184
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       result = election->candidates[candidate]
                                                   ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, ?e["candidates"], 1]

Step 1423:
  program counter:   1185
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["candidates"]) and push the combined address (?e["candidates"][1])
  source code:       result = election->candidates[candidate]
                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, ?e["candidates"][1]]

Step 1424:
  program counter:   1186
  hvm code:          Load
  explanation:       pop address of variable (?e["candidates"][1]) and push value (0)
  start expression:  line=59 column=14
  end expression:    line=59 column=44
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 0]

Step 1425:
  program counter:   1187
  hvm code:          StoreVar result
  explanation:       pop value (0) and store locally in variable "result"
  source code:       result = election->candidates[candidate]
                     ^^^^^^^^
  method variables:  { candidate: 1, election: ?e, result: 0 }
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }]

Step 1426:
  program counter:   1188
  hvm code:          Push PC(714)
  explanation:       push program counter constant 714 ("release")
  start statement:   line=62 column=5
  end statement:     line=62 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(714)]

Step 1427:
  program counter:   1189
  hvm code:          LoadVar election
  explanation:       push value (?e) of variable "election"
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(714), ?e]

Step 1428:
  program counter:   1190
  hvm code:          DelVar election
  explanation:       delete method variable election
  start expression:  line=62 column=15
  end expression:    line=62 column=22
  method variables:  { candidate: 1, result: 0 }

Step 1429:
  program counter:   1191
  hvm code:          Push "locks_can"
  explanation:       push constant "locks_can"
  source code:       release(?(election->locks_can[candidate]))
                                         ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(714), ?e, "locks_can"]

Step 1430:
  program counter:   1192
  hvm code:          Address
  explanation:       pop a key ("locks_can") and an address (?e) and push the combined address (?e["locks_can"])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(714), ?e["locks_can"]]

Step 1431:
  program counter:   1193
  hvm code:          LoadVar candidate
  explanation:       push value (1) of variable "candidate"
  source code:       release(?(election->locks_can[candidate]))
                                                   ^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(714), ?e["locks_can"], 1]

Step 1432:
  program counter:   1194
  hvm code:          DelVar candidate
  explanation:       delete method variable candidate
  start expression:  line=62 column=35
  end expression:    line=62 column=43
  method variables:  { result: 0 }

Step 1433:
  program counter:   1195
  hvm code:          Address
  explanation:       pop a key (1) and an address (?e["locks_can"]) and push the combined address (?e["locks_can"][1])
  source code:       release(?(election->locks_can[candidate]))
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, PC(714), ?e["locks_can"][1]]

Step 1434:
  program counter:   1196
  hvm code:          Apply
  explanation:       pop an argument (?e["locks_can"][1]) and a program counter value (714: "release") and call the method
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> get_votes(?e, 1) --> release(?e["locks_can"][1])
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 19154, ?e["locks_can"][1]]

Step 1435:
  program counter:   714
  hvm code:          Frame release(binsema)
  explanation:       method "release" with argument binsema set to ?e["locks_can"][1]
  file:              /Users/maxhorowitz/opt/miniconda3/lib/python3.9/site-packages/harmony_model_checker/modules/synch.hny
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { binsema: ?e["locks_can"][1], result: None }
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 19154, { "result": 0 }]

Step 1436:
  program counter:   715
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^

Step 1437:
  program counter:   716
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=36 column=9
  end statement:     line=36 column=23
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1438:
  program counter:   717
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 2 to 3: remains atomic
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1439:
  program counter:   718
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  source code:       assert !binsema
                             ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 19154, { "result": 0 }, ?e["locks_can"][1]]

Step 1440:
  program counter:   719
  hvm code:          Load
  explanation:       pop address of variable (?e["locks_can"][1]) and push value (True)
  source code:       assert !binsema
                            ^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 19154, { "result": 0 }, True]

Step 1441:
  program counter:   720
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert !binsema
                     ^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 19154, { "result": 0 }]

Step 1442:
  program counter:   721
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 3 to 2: remains atomic
  source code:       assert !binsema
                     ^^^^^^^^^^^^^^^

Step 1443:
  program counter:   722
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=36 column=9
  end expression:    line=36 column=23

Step 1444:
  program counter:   723
  hvm code:          LoadVar binsema
  explanation:       push value (?e["locks_can"][1]) of variable "binsema"
  start statement:   line=37 column=9
  end statement:     line=37 column=24
  source code:       !binsema = False
                      ^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 19154, { "result": 0 }, ?e["locks_can"][1]]

Step 1445:
  program counter:   724
  hvm code:          DelVar binsema
  explanation:       delete method variable binsema
  start expression:  line=37 column=10
  end expression:    line=37 column=16
  method variables:  { result: None }

Step 1446:
  program counter:   725
  hvm code:          Push False
  explanation:       push constant False
  source code:       !binsema = False
                                ^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 19154, { "result": 0 }, ?e["locks_can"][1], False]

Step 1447:
  program counter:   726
  hvm code:          Store
  explanation:       pop value (False) and address (?e["locks_can"][1]) and store
  source code:       !binsema = False
                     ^^^^^^^^^^
  shared variables:  { EXPECTED_VOTES: [ 3, 0 ], NUM_CANDIDATES: 2, NUM_CITIZENS: 3, WINNER: 0, e: { "candidates": [ 3, 0 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }, number_of_spawned_threads: 4, threads_executed: 4 }
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, 19154, { "result": 0 }]

Step 1448:
  program counter:   727
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  start statement:   line=35 column=5
  end statement:     line=35 column=15
  source code:       atomically:
                     ^^^^^^^^^^^

Step 1449:
  program counter:   728
  hvm code:          Return
  explanation:       push result (None) and restore method variables
  start statement:   line=34 column=1
  end statement:     line=34 column=21
  source code:       def release(binsema):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { result: 0 }
  call trace:        end_test() --> get_votes(?e, 1)
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }, None]

Step 1450:
  program counter:   1197
  hvm code:          Pop
  explanation:       pop and discard value (None)
  file:              electionimpl.hny
  start statement:   line=62 column=5
  end statement:     line=62 column=46
  source code:       release(?(election->locks_can[candidate]))
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 22786, { "i": 1, "result": None }]

Step 1451:
  program counter:   1198
  hvm code:          Return
  explanation:       push result (0) and restore method variables
  start statement:   line=54 column=1
  end statement:     line=54 column=35
  source code:       def get_votes(election, candidate):
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  method variables:  { i: 1, result: None }
  call trace:        end_test()
  stack:             [{:}, { 0, 1 }, 2, 0]

Step 1452:
  program counter:   1424
  hvm code:          StoreVar received_votes
  explanation:       pop value (0) and store locally in variable "received_votes"
  file:              electiontest.hny
  start statement:   line=33 column=13
  end statement:     line=33 column=58
  source code:       let received_votes = election.get_votes(?e, i):
                     ^^^^^^^^^^^^^^^^^^^^
  method variables:  { i: 1, received_votes: 0, result: None }
  stack:             [{:}, { 0, 1 }, 2]

Step 1453:
  program counter:   1425
  hvm code:          ReadonlyInc
  explanation:       increment readonly counter from 0 to 1: becomes readonly
  start statement:   line=34 column=17
  end statement:     line=34 column=58
  source code:       assert EXPECTED_VOTES[i] == received_votes
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1454:
  program counter:   1426
  hvm code:          AtomicInc(lazy)
  explanation:       increment atomic counter from 1 to 2: remains atomic
  start expression:  line=34 column=17
  end expression:    line=34 column=58

Step 1455:
  program counter:   1427
  hvm code:          Push ?EXPECTED_VOTES
  explanation:       push constant ?EXPECTED_VOTES
  source code:       assert EXPECTED_VOTES[i] == received_votes
                            ^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, ?EXPECTED_VOTES]

Step 1456:
  program counter:   1428
  hvm code:          LoadVar i
  explanation:       push value (1) of variable "i"
  source code:       assert EXPECTED_VOTES[i] == received_votes
                                           ^
  stack:             [{:}, { 0, 1 }, 2, ?EXPECTED_VOTES, 1]

Step 1457:
  program counter:   1429
  hvm code:          DelVar i
  explanation:       delete method variable i
  start expression:  line=34 column=39
  end expression:    line=34 column=39
  method variables:  { received_votes: 0, result: None }

Step 1458:
  program counter:   1430
  hvm code:          Address
  explanation:       pop a key (1) and an address (?EXPECTED_VOTES) and push the combined address (?EXPECTED_VOTES[1])
  source code:       assert EXPECTED_VOTES[i] == received_votes
                            ^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, ?EXPECTED_VOTES[1]]

Step 1459:
  program counter:   1431
  hvm code:          Load
  explanation:       pop address of variable (?EXPECTED_VOTES[1]) and push value (0)
  start expression:  line=34 column=24
  end expression:    line=34 column=40
  stack:             [{:}, { 0, 1 }, 2, 0]

Step 1460:
  program counter:   1432
  hvm code:          LoadVar received_votes
  explanation:       push value (0) of variable "received_votes"
  source code:       assert EXPECTED_VOTES[i] == received_votes
                                                 ^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, 0, 0]

Step 1461:
  program counter:   1433
  hvm code:          DelVar received_votes
  explanation:       delete method variable received_votes
  start expression:  line=34 column=45
  end expression:    line=34 column=58
  method variables:  { result: None }

Step 1462:
  program counter:   1434
  hvm code:          2-ary ==
  explanation:       pop 2 values (0, 0); check if both values are the same; push result (True)
  source code:       assert EXPECTED_VOTES[i] == received_votes
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  stack:             [{:}, { 0, 1 }, 2, True]

Step 1463:
  program counter:   1435
  hvm code:          Assert
  explanation:       pop a value (True); do not raise exception
  source code:       assert EXPECTED_VOTES[i] == received_votes
                     ^^^^^^
  stack:             [{:}, { 0, 1 }, 2]

Step 1464:
  program counter:   1436
  hvm code:          AtomicDec
  explanation:       decrement atomic counter from 2 to 1: remains atomic
  source code:       assert EXPECTED_VOTES[i] == received_votes
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Step 1465:
  program counter:   1437
  hvm code:          ReadonlyDec
  explanation:       decrement readonly counter from 1 to 0: no longer readonly
  start expression:  line=34 column=17
  end expression:    line=34 column=58

Step 1466:
  program counter:   1438
  hvm code:          Jump 1415
  explanation:       set program counter to 1415
  start statement:   line=32 column=9
  end statement:     line=32 column=39
  source code:       for i in {0, NUM_CANDIDATES -1}:
                                                   ^

Step 1467:
  program counter:   1415
  hvm code:          Cut(i)
  explanation:       pop index (2) and value ({ 0, 1 }); out of range -> push False
  source code:       for i in {0, NUM_CANDIDATES -1}:
                     ^^^
  stack:             [{:}, False]

Step 1468:
  program counter:   1416
  hvm code:          JumpCond False 1439
  explanation:       pop value (False), compare to False, and jump to 1439 if the same
  start expression:  line=32 column=9
  end expression:    line=32 column=11
  stack:             [{:}]

Step 1469:
  program counter:   1439
  hvm code:          DelVar i
  explanation:       delete method variable i
  start statement:   line=36 column=9
  end statement:     line=36 column=44
  source code:       let winner_idx = election.winner(?e):
                                      ^^^^^^^^^^^^^^^

Step 1470:
  program counter:   1440
  hvm code:          Push PC(1260)
  explanation:       push program counter constant 1260 ("winner")
  start expression:  line=36 column=26
  end expression:    line=36 column=40
  stack:             [{:}, PC(1260)]

Step 1471:
  program counter:   1441
  hvm code:          Push ?e
  explanation:       push constant ?e
  source code:       let winner_idx = election.winner(?e):
                                                       ^
  stack:             [{:}, PC(1260), ?e]

Step 1472:
  program counter:   1442
  hvm code:          Apply
  explanation:       pop an argument (?e) and a program counter value (1260: "winner") and call the method
  source code:       let winner_idx = election.winner(?e):
                                      ^^^^^^^^^^^^^^^^^^^
  call trace:        end_test() --> winner(?e)
  stack:             [{:}, 23090, ?e]

Step 1473:
  program counter:   1260
  hvm code:          Frame winner(election)
  explanation:       method "winner" with argument election set to ?e
  file:              electionimpl.hny
  start statement:   line=76 column=1
  end statement:     line=76 column=21
  source code:       def winner(election):
                     ^^^^^^^^^^^^^^^^^^^^^
  method variables:  { election: ?e, result: None }
  stack:             [{:}, 23090, { "result": None }]

Step 1474:
  program counter:   1261
  hvm code:          DelVar election
  explanation:       delete method variable election
  start statement:   line=77 column=5
  end statement:     line=77 column=17
  source code:       var high = -1
                                ^^
  method variables:  { result: None }

Step 1475:
  program counter:   1262
  hvm code:          DelVar result
  explanation:       delete method variable result
  start expression:  line=77 column=16
  end expression:    line=77 column=17
  method variables:  { }

Step 1476:
  program counter:   1263
  hvm code:          Push -1
  explanation:       push constant -1
  start expression:  line=77 column=16
  end expression:    line=77 column=17
  stack:             [{:}, 23090, { "result": None }, -1]

Step 1477:
  program counter:   1264
  hvm code:          StoreVar high
  explanation:       pop value (-1) and store locally in variable "high"
  source code:       var high = -1
                     ^^^^^^^^^^^^^
  method variables:  { high: -1 }
  stack:             [{:}, 23090, { "result": None }]

Step 1478:
  program counter:   1265
  hvm code:          Push -1
  explanation:       push constant -1
  start statement:   line=78 column=5
  end statement:     line=78 column=16
  source code:       var idx = -1
                               ^^
  stack:             [{:}, 23090, { "result": None }, -1]

Step 1479:
  program counter:   1266
  hvm code:          StoreVar idx
  explanation:       pop value (-1) and store locally in variable "idx"
  source code:       var idx = -1
                     ^^^^^^^^^^^^
  method variables:  { high: -1, idx: -1 }
  stack:             [{:}, 23090, { "result": None }]

Step 1480:
  program counter:   1267
  hvm code:          Load election$candidates
  explanation:       push value of shared variable candidates
  start statement:   line=79 column=5
  end statement:     line=79 column=23
  source code:       for i in candidates:
                              ^^^^^^^^^^
  new mode:          failed
  operation failed:  Load: unknown variable ?election$candidates

================================================
Final state
================================================
Threads:
  T0: pc=1501 terminated atomic __init__()
  T1: pc=1344 terminated test_vote(?e, 0, 0)
  T2: pc=1344 terminated test_vote(?e, 1, 1)
  T3: pc=1344 terminated test_vote(?e, 1, 1)
  T4: pc=1383 terminated test_withdraw(?e, 0, 1, 2)
  T5: pc=1267 failed atomic end_test() --> winner(?e)
Variables:
  EXPECTED_VOTES: [ 3, 0 ]
  NUM_CANDIDATES: 2
  NUM_CITIZENS: 3
  WINNER: 0
  e: { "candidates": [ 3, 0 ], "citizens": [ { "voted": True, "voted_for": 0 }, { "voted": True, "voted_for": 1 }, { "voted": True, "voted_for": 1 } ], "locks_can": [ False, False ], "locks_cit": [ False, False, False ] }
  number_of_spawned_threads: 4
  threads_executed: 4
